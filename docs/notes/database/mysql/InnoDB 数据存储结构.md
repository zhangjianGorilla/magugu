---
title: InnoDB 数据存储结构
createTime: 2024/12/19 14:19:19
permalink: /database/ou1fdhae/
---

### 1. 数据库的存储结构：页

索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL 服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据。

由于 InnoDB 是 MySQL 的默认存储引擎，所以本章剖析 InnoDB 存储引擎的数据存储结构。

#### 1.1 磁盘与内存交互基本单位：页

InnoDB 将数据划分为若干个页，InnoDB 中页的大小默认为 16KB。

以页作为磁盘和内存之间交互的基本单位，也就是一次最少丛磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页 (Page)，数据库 I/O 操作的最小单位是页**。一个页中可以存储多个行记录。

> 记录是按照行来存储的，但是数据库的读取并不是以行为单位，否则一次读取 (也就是一次 I/O 操作) 只能处理一行数据，效率会非常低。

![数据页](/mysql/数据页.png)

#### 1.2 页结构概述

页 a、页 b、页 c ... 页 n 这些页可以不再物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，再通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，啊啊然后再便利该槽对应分组中的记录即可快速找到指定的记录。

#### 1.3 页的大小

不同的数据库管理系统的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 16KB，我们可以通过下面的命令来进行查看：

```sql
show variables like '%innodb_page_size%';
```

SQL Server 中页的大小为 8KB，而在 Oracle 中我们用术语“块” (Block) 来代表“页”，Oracle 支持的块的大小为 2KB、4KB、8KB、16KB、32KB 和 64KB。

#### 1.4 页的上层结构

另外在数据库中，还存在着区 (Extent)、段 (Segment) 和表空间 (Tablespace) 的概念。行、页、区、段、表空间的关系如下图所示：

![行页区段表空间的关系](/mysql/行页区段表空间的关系.png)

区 (Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64 * 16KB = 1MB。

段 (Segment) 由一个或多个区组成，区在文件系统中是一个连续分配的空间 (在 InnoDB 中是连续的 64 个页)，不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

表空间 (Tablespace) 是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。

### 2. 页的内部结构

页如果按类型划分的话，常见的有数据页 (保存 B+ 树节点)、系统页、Undo 页 和 事物数据页等。数据页是我们最常使用的页。

数据页的 16KB 大小的存储空间被划分为七个部分，分别是文件头 (File Header)、页头 (Page Header)、最大最小记录 (Infimum + supremum)、用户记录 (User Records)、空闲空间 (Free Space)、页目录 (Page Directory) 和文件尾 (File Tailer)。

页结构的示意图如下所示：

![页结构的示意图](/mysql/页结构的示意图.png)

这 7 个部分作用分别如下：

| 名称               | 占用大小 | 说明                                 |
| ------------------ | -------- | ------------------------------------ |
| File Header        | 38 字节  | 文件头，描述页的信息                 |
| Page Header        | 56 字节  | 页头，页的状态信息                   |
| Infimum + Supremum | 26 字节  | 最大和最小记录，这时两个虚拟的行记录 |
| User Records       | 不确定   | 用户记录，存储行记录内容             |
| Free Space         | 不确定   | 空闲记录，页中还没有被使用的空间     |
| Page Directory     | 不确定   | 页目录，存储用户记录的相对位置       |
| File Trailer       | 8 字节   | 文件尾，校验页是否完整               |

我们可以把这 7 个结构分成 3 个部分。

#### 2.1 File Header (文件头部) 和 File Trailer (文件尾部)

首先是文件通用部分，也就是文件头和文件尾。

**文件头部信息**

不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等，所有的数据页会组成一个双链表。这个部分占用固定的 38 个字节，是由下边这些内容组成的：

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4 字节       | 页的校验和 (checksum 值)                                     |
| FIL_PAGE_OFFSET                  | 4 字节       | 页号                                                         |
| FIL_PAGE_PREV                    | 4 字节       | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4 字节       | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8 字节       | 页面被最后修改时对应的日志序列位置 (英文名是：Log Sequence Number) |
| FIL_PAGE_TYPE                    | 2 字节       | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 字节       | 尽在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 字节       | 页属于哪个表空间                                             |

其中：

- FIL_PAGE_OFFSET

  每一个页都有一个单独的页号，InnoDB通过页号可以唯一定位一个页。

- FIL_PAGE_TYPE

  这个代表当前页的类型。InnoDB 为了不同的目的而把页分为不同的类型，上面介绍的都是存储记录的数据页，还有很多其它的类型的页：

  | 类型名称                | 十六进制 | 描述                   |
      | ----------------------- | -------- | ---------------------- |
  | FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用     |
  | FIL_PAGE_UNDO_LOG       | 0x0002   | Undo 日志页            |
  | FIL_PAGE_INODE          | 0x0003   | 段信息节点             |
  | FIL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer 空闲列表 |
  | FIL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer 位图     |
  | FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                 |
  | FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据           |
  | FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息         |
  | FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页             |
  | FIL_PAGE_TYPE_BLOB      | 0x000A   | 溢出页                 |
  | FIL_PAGE_INDEX          | 0x45BF   | 索引页，也就是数据页   |

  我们存放记录的数据页的类型其实是 FIL_PAGE_INDEX，也就是所谓的索引页。

**数据页的链接实现**

在文件头部内容中有两个属性：FIL_PAGE_PREV 和 FIL_PAGE_NEXT

InnoDB 都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就跟别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。

数据页之间组成的双向链表：

![数据页之间组成的双向链表](/mysql/数据页之间组成的双向链表.png)

![数据页之间组成的双向链表](/mysql/数据页之间组成的双向链表2.png)

**检验页的完整性**

文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM

代表当前页面的检验和 (checksum)。

> 什么是校验和？
>
> 就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为检验和。
>
> 在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。

InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整性。

为了检测一个页是否完整 (也就是在同步的时候有没有发生只同步一半的尴尬情况)，这时可以通过文件尾的检验和 (checksum 值) 与文件头的检验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。

**文件尾部**

文件尾部总共占用 8 个字节

- 前 4 个字节代表页的校验和：这个部分适合 File Header 中的校验和相对应的。
- 后 4 个字节代表页面被最后修改时对应的日志序列位置 (LSN)。

这个部分也是为了校验页的完整性的，如果首部和尾部的 LSN 值校验不成功的话，就说明同步过程出现了问题。

#### 2.2 User Records (用户记录)、最大最小记录、Free Space (空闲空间)

第二部分是记录部分，页的主要作用是存储记录，所以”最大和最小记录“和“用户记录”部分占了页结构的主要空间。

![页结构空间示意图](/mysql/页结构空间示意图.png)

**空闲空间 (Free Space)**

我们自己存储的记录会按照指定的行格式存储到 User Records 部分。但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。

**用户记录 (User Records)**

User Records 中的这些记录按照指定的行格式一条一条摆在 User Records 部分，相互之间形成单链表。用户记录里的

**最小最大记录 (Infimum + Supremum)**

记录可以比较大小吗？

记录可以比大小，对于一条完整的记录来说，比较就的大小就是比较主键的大小。比方说我们插入的 4 行记录的主键值分别是：1、2、3、4，这就意味着这 4 条记录是从小到大依次递增。

InnoDB 规定的最小记录与最大记录这两条记录的构造十分简单，都是由 5 个字节大小的记录头信息和 8 字节大小的一个固定的部分组成的，如图：

![最小最大记录](/mysql/最小最大记录.png)

这两条记录不是我们自己定义的记录，所以她们并不存放在页的 User Records 部分，她们被单独放在一个称为 Infimum + Supremum 的部分，如图：

![最小最大记录](/mysql/最小最大记录2.png)

#### 2.3 Page Directory (页目录)、Page Header (页面头部)

**页目录**

在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了目录页这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索提升效率。

**页目录是如何构成的**

需求：根据主键值查找页中的某条记录，如何实现快速查找呢？

```sql
SELECT * FROM page_demo = WHERE c1 = 3;
```

最笨的办法：顺序查找

从 Infimum 记录 (最小记录) 开始，沿着链表一直往后找，总有一天会找到或者找不到，在找的时候还能投机取巧，因为链表中哥哥记录的值是按照从小到大的顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值是，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。

如果一个页中存储了非常多的记录，这么查找性能很差。

好办法：使用目录，二分查找法

- 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。
- 第一组，也就是最小记录所在的分组只有一个记录；最后一组，就是最大记录所在的分组，会有 1～8 条记录；其余的组记录数量在 4～8 条之间。这样做的好处是，除了第一组以外，其余组的记录树会尽量平分。
- 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。
- 页目录用来存储魅族最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，魅族的地址偏移量也被称之为槽 (slot)，每个槽相当于指针指向了不同组的最后一个记录。

页目录分组的个数如何确定？

为什么最小记录的 n_owned 值为 1，而最大记录的 n_owned 值为 5 呢？

InnoDB 规定：对于最小记录所在的分组只能有一条记录，最大记录所在的分组拥有的记录条数只能在 1～8 之间，剩下的分组中记录的条数范围只能在 4～8 之间。

分组是按照下面的步骤进行的：

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，她们分属于两个分组。
- 之后没插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，知道该组中的记录数等于 8 个。
- 在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

**页面头部**

为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，这个部分占用固定的 56 个字节，专门存储各种状态信息。

| 名称              | 占用空间大小 | 描述                                                         |
| ----------------- | ------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2 字节       | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | 2 字节       | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space  |
| PAGE_N_HEAP       | 2 字节       | 本页中的记录的数量 (包括最小和最大记录以及标记为删除的记录)  |
| PAGE_FREE         | 2 字节       | 第一个已经标记为删除的记录地址 (各个已删除的记录通过 next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用) |
| PAGE_GARBAGE      | 2 字节       | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2 字节       | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2 字节       | 记录插入的方向                                               |
| PAGE_N_DIRECTION  | 2 字节       | 一个方向连续插入的记录数量                                   |
| PAGE_N_RECS       | 2 字节       | 该页中记录的数量 (不包括最小和最大记录以及被标记为删除的记录) |
| PAGE_MAX_TRX_ID   | 8 字节       | 修改当前页的最大事务 ID，该值尽在二级索引中定义              |
| PAGE_LEVEL        | 2 字节       | 当前页在 B+ 树中所处的层级                                   |
| PAGE_INDEX_ID     | 8 字节       | 索引 ID，表示当前页属于哪个索引                              |
| PAGE_BTR_SEG_LEAF | 10 字节      | B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义              |

#### 2.4 从数据页的角度看 B+ 树如何查询

一棵 B+ 树按照节点类型可以分成两部分：

- 叶子节点，B+ 树最底层的节点，节点的高度为 0，存储行记录。
- 非叶子节点，节点的高度大于 0，存储索引键和页面指针，并不存储记录本身。

![B+树查询](/mysql/B+树查询.png)

当我们从页结构来理解 B+ 树的时候，可以帮我们理解一些通过索引进行检索的原理：

**B+ 树是如何进行记录检索的**？

如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，知道找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽 (slot) 采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。

**普通索引和唯一索引在存储效率上有什么不同**？

我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？

唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存储在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。

### 3. InnoDB 行格式 (或记录格式)

平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或记录格式。InnoDB 存储引擎设计了 4 种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。

查看 MySQL8 的默认行格式：

```sql
SELECT @@innodb_default_row_format;
```

也可以使用如下语法查看具体表使用的行格式：

```sql
SHOW TABLE STATUS like 表名\G
```

#### 3.1 指定行格式的语法

在创建或修改表的语句中指定行格式：

```sql
CREATE TABLE 表名 (列信息) ROW_FORMAT=行格式名称;
ALTER TABLE 表名 ROW_FORMAT=行格式名称;
```

举例：

```sql
CREATE TABLE record_test_table(
	col1 VARCHAR(8),
  col2 VARCHAR(8) NOT NULL,
  col3 char(8),
  col4 VARCHAR(8)
) CHARSET=ascii ROW_FORMAT=COMPACT;

INSERT INTO record_test_table(col1, col2, col3, col4)
VALUES
('zhangsan','lisi','wangwu','laji'),
('xiaoming','xiaohong',NULL,NULL);
```

#### 3.2 COMPACT 行格式

在 MySQL 5.1 版本中，默认设置为 Compact 行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。

![compact行格式示意图](/mysql/compact行格式示意图.png)

**变长字段长度列表**

MySQL 支持一些变长的数据类型，比如 VARCHAR(M)、VARBINARY(M)、TEXT 类型，BLOB 类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。

> 注意：这里面存储的变长长度和字段顺序是反过来的。比如两个 varchar 字段在表结构的顺序是 a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是 15，10，是反过来的。

以 record_test_table 表中的第一条记录举例：因为 record_test_table 表的 col1、col2、col4 都是 VARCHAR(8) 类型的，所以这三个列的值的长度都需要保存在记录开头处，注意 record_test_table 表中的各个列都使用的是 ascii 字符集 (每个字符只需要 1 字节来进行编码)。

| 列名 | 存储内容   | 内容长度 (十进制表示) | 内容长度 (十六进制表示) |
| ---- | ---------- | --------------------- | ----------------------- |
| col1 | 'zhangsan' | 8                     | 0x88                    |
| col2 | 'lisi'     | 4                     | 0x04                    |
| col4 | 'laji'     | 6                     | 0x06                    |

又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是 (各个字节之间实际上没有空格，用空格隔开只是方便理解)：06 04 08

把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：

![compact行格式示意图](/mysql/compact行格式示意图-1.png)

**NULL 值列表**

Compact 行格式会把可以为 NULL 的列统一管理起来，存在一个标记为 NULL 值列表中。如果表中没有允许存储 NULL 的列，则 NULL 值列表也不存在了。

为什么定义 NULL 值列表？

之所以要存储 NULL 是因为数据都是需要对齐的，如果没有标注出来 NULL 值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据的头部开辟出一块空间专门用来记录改行数据哪些是非空数据，哪些是空数据，格式如下：

- 二进制位的值为 1 时，代表该列的值为 NULL。
- 二进制位的值为 0 时，代表该列的值不为 NULL。

例如：字段 a、b、c，其中 a 是主键，在某一行中存储的数依次是 a = 1、b = null、c = 2。那么 Compact 行格式中的 NULL 值列表中存储：01。第一个 0 表示 c 不为 null，第二个 1 表示 b 是 null。这里之所以没有 a 是因为数据库会自动跳过主键，因为主键肯定是非 NULL 且唯一的，在 NULL 值列表的数据中就会自动跳过主键。

record_test_table 的两条记录的 NULL 值列表就如下：

第一条记录：

![第一条记录](/mysql/第一条记录.png)

第二条记录：

![第二条记录](/mysql/第二条记录.png)

**记录头信息**

```sql
CREATE TABLE page_demp(
	c1 INT,
  c2 INT,
  c3 VARCHAR(10000),
  PRIMARY kEY(c1)
)CHARSET=ascii ROW_FORMAT=Compact;
```

这个表中的记录的行格式示意图：

![行格式示意图](/mysql/行格式示意图.png)

这些记录头信息中各个属性如下：

| 名称         | 大小 (单位：bit) | 描述                                                         |
| ------------ | ---------------- | ------------------------------------------------------------ |
| 预留位 1     | 1                | 没有使用                                                     |
| 预留位 2     | 1                | 没有使用                                                     |
| delete_mask  | 1                | 标记该记录是否被删除                                         |
| min_rec_mask | 1                | B+ 树的每层非叶子节点中的最小记录都会添加该标记              |
| n_owned      | 4                | 表示当前记录拥有的记录数                                     |
| heap_no      | 13               | 表示当前记录在记录堆的位置信息                               |
| record_type  | 3                | 表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶子节点记录，2 表示最小记录，3 表示最大记录 |
| next_record  | 16               | 表示下一条记录的相对位置                                     |

简化后的行格式示意图：

![简化后的行格式示意图](/mysql/简化后的行格式示意图.png)

```sql
INSERT INTO page_demp
VALUES
(1, 100, 'song'),
(2, 200, 'tong'),
(3, 300, 'zhan'),
(4, 400, 'lisi')
```

![page_demo数据](/mysql/page_demo数据.png)

- delete_mask

  这个属性标记着当前记录是否被删除，占用 1 个二进制位。

    - 值为 0：代表记录并没有被删除
    - 值为 1:代表记录被删除

  被删除的记录为什么还在页中存储呢？

  你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其它的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- min_rec_mask

  B+ 树的每层非叶子节点中最小记录都会添加该标记，min_rec_mask 值为 1。我们自己插入的四条记录 min_rec_mask 值都是 0，意味着他们都不是 B+ 树的非叶子节点中的最小记录。

- record_type

  这个属性表示当前记录的类型，一共有 4 种类型的记录：

  0：表示普通记录

  1：表示 B+ 树非叶子节点记录

  2：表示最小记录

  3：表示最大记录

  从图中我们可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。

- heap_no

  这个属性表示当前记录在本页中的位置。

  从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：2、3、4、5。

  怎么不见 heap_no 值为 0 和 1 的记录呢？

  MySQL 会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的 heap_no 值分别是 0 和 1，也就是说它们的位置最靠前。

- n_owned

  页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。

- next_record

  记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。

  比如：第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。

  注意，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录 (也就是最小记录) 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录 (也就是最大记录)。下图用箭头代替偏移量表示 next_record。

  ![next_record示意图](/mysql/next_record示意图.png)

    - 删除操作

      从表中删除掉一条记录，这个链表也是会跟着变化：

        ```sql
        DELETE FROM page_demo WHERE c1 = 2;
        ```

      删掉第二条记录后的示意图就是：

      ![删除操作示意图](/mysql/删除操作示意图.png)

      从图中可以看出来，删除第二条记录前后主要发生了这些变化：

        - 第二条记录并没有从存储空间中移除，而是把该记录的 delete_mask 值设置为 1。
        - 第二条记录的 next_record 值变为了 0，意味着该记录没有下一条记录了。
        - 第一条记录的 next_record 指向了第三条记录。
        - 最大记录的 n_owned 值从 5 变成了 4。

      所以，不论我们怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

    - 添加操作

      主键值为 2 的记录被我们删掉了，但是存储空间却没有回收，如果再次把这条记录插入到表中，会发生什么事呢？

        ```sql
        INSERT INTO page_demo VALUES(2, 200, 'tong');
        ```

      看一下记录的存储情况：

      ![添加操作示意图](/mysql/添加操作示意图.png)

      直接服用了原来被删除记录的存储空间。

      说明：

      当数据页中存在多条被删掉的记录时，这些记录的 next_record 属性将会把这些被删除的记录组成一个垃圾链表，以备之后重用这部分存储空间。

**记录的真实数据**

记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：

| 列名           | 是否必须 | 占用空间 | 描述                    |
| -------------- | -------- | -------- | ----------------------- |
| row_id         | 否       | 6 字节   | 行 ID，唯一标识一条记录 |
| transaction_id | 是       | 6 字节   | 事务 ID                 |
| roll_pointer   | 是       | 7 字节   | 回滚指针                |

实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。

- 一个表没有手动定义主键，则会选取一个 Unique 键作为主键，如果连 Unique 键都没有定义的话，则会为表默认添加一个名为 row_id 的隐藏列作为主键。所以 row_id 是在没有自定义主键以及 Unique 键的情况下才会存在的。
- 事务 ID 和回滚指针在后面描述

#### 3.3 Dynamic 和 Compressed 行格式

**行溢出**

InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。

很多 DBA 喜欢 MySQL 数据库提供的 VARCHAR(M) 类型，认为可以存放 65535 字节。这是真的吗？如果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们看看 VARCHAR(65535) 是否可用。

```sql
CREATE TABLE varchar_size_demo(c VARCHAR(65535)) CHARSET = ascii ROW_FORMAT = Compact;
# 结果如下：
ERROR 1118 (42000): Row size too large.
```

报错的信息表达的意思是：MySQL 对一条记录占用的最大存储空间是有限制的，除 BLOB 或 TEXT 类型的列之外，其他所有的列 (不包含隐藏列和记录头信息) 占用的字节长度加起来不能超过 65535 个字节。

这个 65535 个字节除了列本身的数据之外，还包括一些其它的数据，以 Compact 行格式为例，比如我们为了存储一个 VARCHAR(M) 类型的列，除了真实数据占有空间以外，还需要记录的额外信息。

如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据， 因为变长字段的长度占用 2 个字节，NULL 值标识需要占用 1 个字节。

```sql
CREATE TABLE varchar_size_demo(c VARCHAR(65532)) CHARSET = ascii ROW_FORMAT = Compact;
```

如果有 NOT NULL 属性，那么就不需要 NULL 值标识，也就可以多存储一个字节，即 65533 个字节。

```sql
CREATE TABLE varchar_size_demo(c VARCHAR(65533) not null) CHARSET = ascii ROW_FORMAT = Compact;
```

通过上面的案例，我们可以知道一个页的大小一般是 16KB，也就是 16384 字节，而一个 VARCHAR(M) 类型的列就最多可以存储 65533 个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。

在 Compact 和 Redundant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分也存储，然后记录的真实数据处用 20 个字节存储指向这些页的地址 (当然这 20 个字节中国呢还包括这些分散在其他页面中的数据的占用的字节数)，从而可以找到剩余数据所在的页。这称为页的扩展，举例如下：

![页的扩展](/mysql/页的扩展.png)

在 MySQL 8.0 中，默认行格式就是 Dynamic，Dynamic、Compressed 行格式和 Compact 行格式挺像，只不过在处理行溢出数据时有分歧：

- Compressed 和 Dynamic 两种记录格式对于存放在 BLOB 中的数据采用了完全的行溢出的方式。如图，在数据页中只存放 20 个字节的指针 (溢出页的地址)，实际的数据都存放在 Off Page (溢出页) 中。
- Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据 (存放 768 个前缀字节)。

Compressed 行记录格式的另一个功能就是，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。

![Compressed行记录格式](/mysql/Compressed行记录格式.png)

#### 3.4 Redundant 行格式

Redundant 是 MySQL 5.0 版本之前 InnoDB 的行记录存储方式，MySQL 5.0 支持 Redundant 是为了兼容之前版本的页格式。

现在我们把表 record_test_table 的行格式修改为 Redundant：

```sql
ALTER TABLE recoord_test_table ROW_FORMAT = Redundant;
```

![Redundant行格式示意图](/mysql/Redundant行格式示意图.png)

从上图可以看到，不同于 Compact 行记录格式，Redundant 行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。

### 4. 区、段与碎片区

#### 4.1 为什么要有区？

B+ 树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍 B+ 树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机 I/O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机 I/O 是非常慢的，所以我们应该尽量让链表中相邻的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序 I/O。

引入区的概念，一个区就是在物理位置上连续的 64 个页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费 (数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机 I/O，功大于过。

#### 4.2 为什么要有段？

对于范围查询，其实是对 B+ 树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点由自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段 (segment)，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。

除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段友数据段、索引段、回滚段。数据段即为 B+ 树的叶子节点，索引段即为 B+ 树的非叶子节点。

在 InnoDB 存储引擎中，对段的管理都是由引擎自身所完成的，DBA 不能也没有必要对其进行控制。这从一定程度上简化了 DBA 对于段的管理。

段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。

#### 4.3 为什么要有碎片区？

默认情况下，一个使用 InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成两个段，而段是以区为单位申请存储空间的，一个区默认占用 1M (64 * 16KB= 1024KB) 存储空间，所以默认情况下一个只存了几条记录的小表也需要 2M 的存储空间么？以后每次添加一个索引都要多申请 2M 的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。

为了考虑以完整的区为单位分配给某个段对于数据量小的表太浪费存储空间的情况，InnoDB 提出了一个碎片 (fragment) 区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段 A，有些页用于段 B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

所以此后为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了 32 个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。

所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。

#### 4.4 区的分类

区大体上可以分为四种类型：

- 空闲的区 (FREE)：现在还没有用到这个区中的任何页面。
- 有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。
- 没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。
- 附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。

处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区市附属于某个段的。

> 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全都隶属于某个段，而处于 FREE、FREE_FRAG 和 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。

### 5. 表空间

表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。

表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库有一个或多个表空间组成，表空间从管理上可以划分为系统表空间 (System tablespace)、独立表空间 (File-per-table tablespace)、撤销表空间 (Undo Tablespace) 和临时表空间 (Temporary Tablespace) 等。

#### 5.1 独立表空间

独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行迁移。

空间可以回收 (DROP TABLE 操作可以自动回收表空间；其他情况，表空间不能自己回收)。如果对于统计分析或事日志表，删除大量数据后可以通过：`alter table TableName engine=innodb`；回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。

**独立表空间结构**

独立表空间由段、区、页组成。

**真实表空间对应的文件大小**

我们到数据目录里看，会发现一个新建的表对应的 `.ibd` 文件只占用了 96k，才 6 个页面大小 (MySQL 5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。

**查看 InnoDB 的表空间类型：**

```sql
show variables like 'innodb_file_per_table';
```

你能看到 innodb_file_per_table=ON，这就意味着每张表都会单独保存为一个 .ibd 文件。

#### 5.2 系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整个 MySQL 进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。

**InnoDB 数据字典**

每当我们向一个表中插入一条记录的时候，MySQL 检验过程如下：

先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。所以说，MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：

- 某个表属于哪个表空间，表里边有多少列
- 表对应的每一个列的类型是什么
- 该表有多少索引，每个索引对应哪几个字段，该索引对应的跟页面在哪个表空间的哪个页面
- 该表有哪些外键，外键对应哪个表的哪些列
- 某个表空间对应文件系统上文件路径是什么
- ……

上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据。InnoDB存储引擎特意定义了一些列的内部系统表 (internal system table) 来记录这些元数据：

| 表名             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| SYS_TABLES       | 整个 InnoDB 存储引擎中所有的表的信息                         |
| SYS_COLUMNS      | 整个 InnoDB 存储引擎中所有的列的信息                         |
| SYS_INDEXES      | 整个 InnoDB 存储引擎中所有的索引的信息                       |
| SYS_FIELDS       | 整个 InnoDB 存储引擎中所有的索引对应的列的信息               |
| SYS_FOREIGN      | 整个 InnoDB 存储引擎中所有的外键的信息                       |
| SYS_FOREIGN_COLS | 整个 InnoDb 存储引擎中所有的外键对应的信息                   |
| SYS_TABLESPACES  | 整个 InnoDB 存储引擎中所有的表空间信息                       |
| SYS_DATAFILES    | 整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息 |
| SYS_VIPTUAL      | 整个 InnoDB 存储引擎中所有的虚拟生成列的信息                 |

这些系统表也被称为数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS 这四个表尤其重要，称之为基本系统表 (basic system tables)，我们先看看这四个表的结构：

**SYS_TABLES 表结构**

| 列名       | 描述                                                |
| ---------- | --------------------------------------------------- |
| NAME       | 表的名称。主键                                      |
| ID         | InnoDB 存储引擎中每个表都有一个唯一的ID。(二级索引) |
| N_COLS     | 该表拥有列的个数                                    |
| TYPE       | 表的类型，记录了一些文件格式、行格式、压缩等信息    |
| MIX_ID     | 已过时，忽略                                        |
| MIX_LEN    | 表的一些额外的属性                                  |
| CLUSTER_ID | 未使用，忽略                                        |
| SPACE      | 该表所属表空间的ID                                  |

**SYSCOLUMNS 表结构**

| 列名     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| TABLE_ID | 该列所属表对应的 ID。                                        |
| POS      | 该列在表中是第几列                                           |
| NAME     | 该列的名称                                                   |
| MTYPE    | main data type，主数据类型，就是那堆 INT、CHAR、VARCHAR、FLOAT、DOUBLE 之类的东东 |
| PRTYPE   | precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许 NULL 值，是否允许负数啥的 |
| LEN      | 该列最多占用存储空间的字节数                                 |
| PREC     | 该列的精度，不过这列貌似都没有使用，默认值都是 0             |

**SYS_INDEXES 表结构**

| 列名            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| TABLE_ID        | 该索引所属表对应的ID                                         |
| ID              | InnoDB 存储引擎中每个索引都有一个唯一的 ID                   |
| NAME            | 该索引的名称                                                 |
| M_FIELDS        | 该索引包含列的个数                                           |
| TYPE            | 该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型 |
| SPACE           | 该索引根页面所在的表空间                                     |
| PAGE_NO         | 该索引根页面所在的页面号                                     |
| MERGE_THRESHOLD | 如果页面中的记录被删除到某个比列，就把该页面和相邻页面合并，这个值就是这个比例 |

**SYS_FIELDS 表结构**

| 列名     | 描述                         |
| -------- | ---------------------------- |
| INDEX_ID | 该索引列所属的索引的ID       |
| POS      | 该索引列在某个索引中是第几列 |
| COL_NAME | 该索引列的名称               |

注意：用户是不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表：

```sql
use information_schema;
show tables like 'innodb_sys%';
```

在 information_schema 数据库中的这些以 INNODB_SYS 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 SYS 开头的那些表)，而是在存储引擎启动时读取这些以 SYS 开头的系统表，然后填充到这些以 INNODB_SYS 开头的表中。以 INNODB_SYS 开头的表和以 SYS 开头的表中的字段并不完全一样，但供参考已经足矣。

### 附录：数据页加载的三种方式

InnoDB 从磁盘中读取数据的最小单位是数据页。而你想得到的 id = xxx 的数据，就是这个数据页众多行中的一行。对于 MySQL 存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按数据页形式进行存放的，当其加载到 MySQL 中我们称之为缓存页。

如果缓冲池中没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取效率都是不同的：

#### 内存读取

如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。

![内存读取](/mysql/内存读取.png)

#### 随机读取

如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在 10ms 左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间 (包括了寻到和半圈旋转时间)，有 3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁盘服务缓冲区传输到数据缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。

![随机读取](/mysql/随机读取.png)

#### 顺序读取

顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I/O 操作了。如果一个磁盘的吞吐量是 40MB/S，那么对于一个 16KB 大小的页来说，一次可以顺序读取 2560 (40MB/16KB) 个页，相当于一个页的读取时间为 0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。