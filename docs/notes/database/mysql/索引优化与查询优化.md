---
title: 索引优化与查询优化
createTime: 2024/12/19 14:22:11
permalink: /database/240qekji/
---

都有哪些维度可以进行数据库调优？简言之：

- 索引失效、没有充分利用到索引——索引建立
- 关联查询太多 JOIN (设计缺陷或不得已的需求) ——SQL 优化
- 服务器调优及各个参数设置 (缓冲、线程数等)——调整 my.cnf
- 数据过多——分库分表

SQL 查询优化的技术大致可以分成物理查询优化和逻辑查询优化两大块。

- 物理查询优化是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。
- 逻辑查询优化就是通过 SQL 等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。

### 1. 数据准备

#### 1.1 建表

```sql
CREATE TABLE class(
	id INT(11) NOT NULL AUTO_INCREMENT,
  className VARCHAR(30) DEFAULT NULL,
  address VARCHAR(40) DEFAULT NULL,
  monitor INT NULL,
  PRIMARY KEY (id)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE student (
	id INT(11) NOT NULL AUTO_INCREMENT,
  stuno INT NOT NULL,
  name VARCHAR(20) DEFAULT NULL,
  age INT(3) DEFAULT NULL,
  classId INT(11) DEFAULT NULL,
  PRIMARY KEY (id)
  # CONSTRAINT fk_class_id FOREIGN KEY (classId) REFERENCES t_class (id)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

#### 1.2 设置参数

```sql
# 开启允许创建函数设置：
set global log_bin_trust_function_creators=1;
```

#### 1.3 创建函数

```sql
# 生成随机字符串
DELIMITER //
CREATE FUNCTION rand_string(n INT)
	RETURNS VARCHAR(255)	#	该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str = CONCAT(return_str, SUBSTRING(chars_str, FLOOR(1 + RAND() * 52), 1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;

# 生成随机班级编号
DELIMITER //
CREATE FUNCTION rand_num(from_num INT, to_num INT)
	RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num + RAND() * (to_num - from_num + 1));
RETURN i;
END //
DELIMITER ;

# 删除函数
DROP FUNCTION 函数名;
```

#### 1.4 创建存储过程

```sql
# 创建往 stu 表中插入数据的存储过程
DELIMITER //
CREATE PROCEDURE insert_stu(START INT, max_num INT)
BEGIN
DECLARE i INT DEFAULT 0;
	SET autocommit = 0;    # 设置手动提交事物
	REPEAT      # 循环
	SET i = i + 1;    # 赋值
	INSERT INTO student (stuno, name, age, classId) VALUES
	((START + i), rand_string(6), rand_num(1, 50), rand_num(1, 1000));
	UNTIL i = max_num
	END REPEAT;
	COMMIT;			# 提交事物
END //
DELIMITER ;

# 往 class 表中插入数据的存储过程
DELIMITER //
CREATE PROCEDURE insert_class(max_num INT)
BEGIN
DECLARE i INT DEFAULT 0;
	SET autocommit = 0;    # 设置手动提交事物
	REPEAT      # 循环
	SET i = i + 1;    # 赋值
	INSERT INTO class (classname, address, monitor) VALUES
	(rand_string(8), rand_string(10), rand_num(1, 100000));
	UNTIL i = max_num
	END REPEAT;
	COMMIT;			# 提交事物
END //
DELIMITER ;

# 删除存储过程
DROP PROCEDURE 存储过程名;
```

#### 1.5 调用存储过程

```sql
# 向 class 表中添加一万条数据
CALL insert_class(10000);
# 向 stu 表中添加 50 万条数据
CALL insert_stu(100000, 500000);
```

#### 1.6 删除某表上的索引

```sql
DELIMITER //
CREATE PROCEDURE proc_drop_index(dbname VARCHAR(200), tablename VARCHAR(200))
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE ct INT DEFAULT 0;
    DECLARE _index VARCHAR(200) DEFAULT '';
    DECLARE _cur CURSOR FOR SELECT index_name FROM information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND index_name <> 'PRIMARY';
    DECLARE CONTINUE HANDLER FOR NOT FOUND set done = 2;
    OPEN _cur;
    FETCH _cur INTO _index;
    WHILE _index<>'' DO
      SET @str = CONCAT("drop index ", _index, " on ", tablename);
      PREPARE sql_str FROM @str;
      EXECUTE sql_str;
      DEALLOCATE PREPARE sql_str;
      SET _index='';
      FETCH _cur INTO _index;
    END WHILE;
	CLOSE _cur;
END //
DELIMITER ;

# 调用
CALL proc_drop_index("dbname", "tablename");
```

### 2. 索引失效案例

MySQL 中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。

- 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。
- 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。

大多数情况下都 (默认) 采用 B+ 树来构建索引。只是空间列类型的索引使用 R-树，并且 MEMORY 表还支持 hash 索引。

其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？给予 cost 开销 (CostBaseOptimizer)，它不是基于规则 (Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。

#### 2.1 全值匹配

系统中经常出现的 SQL 语句如下：

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30;
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND classId = 4;
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND classId = 4 AND `NAME` = 'abcd';
```

建立索引：

```sql
CREATE INDEX idx_age ON student(age);
CREATE INDEX idx_age_classid ON student(age, classId);
CREATE INDEX idx_age_classid_name ON student(age, classId, name);
```

创建索引前的查询时间是 0.137s，创建索引后的查询时间是 0.001s。

#### 2.2 最佳左前缀法则

在 MySQL 建立联合索引时，会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.`name` = 'abcd';
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId = 1 AND student.`name` = 'abcd';
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId = 4 AND student.age = 30 AND student.`name` = 'abcd';
```

MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用**。如果查询条件中没有使用这些字段中第一个字段时，多列或联合索引不会被使用。

> 拓展：Alibaba《Java 开发手册》
>
> 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

#### 2.3 主键插入顺序

对于一个使用 InnoDB 存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1～100 之间，如果此时再插入一条主键值为 9 的记录，那它插入的位置在 8 和 10 之间，但是这个数据页已经满了，再插进来就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着性能损耗。所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值一次递增，这样就不会发生这样的性能损耗了。所以建议：让主键具有 AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。

我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，再插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。

#### 2.4 计算、函数、类型转换到值索引失效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.`name` LIKE 'abc%';

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.`name`, 3) = 'abc';

CREATE index idx_name ON student(name);
```

上面两个 SQL，第一个索引生效，第二个索引失效。

#### 2.5 类型转换到值索引失效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME = 123
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_name      | NULL | NULL    | NULL | 499086 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME = '123';
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_name      | idx_name | 63      | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
```

student 表中 name 字段是字符串类型，第一个 SQL 在执行时，会隐式将 name 转换成 整形，所以会导致索引失效。

> 设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类习惯转换的情况。

#### 2.6 范围条件右边的列索引失效

```sql
CREATE INDEX idx_age_classid_name ON student(age, classId, name);
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND classId > 20 AND `NAME` = 'abc';
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys        | key                  | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_age_classid_name | idx_age_classid_name | 10      | NULL | 19008 |    10.00 | Using index condition |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+
```

根据 key_len 可以看出该 SQL 只用到了联合索引的 age 和 classId，name 并没有用到。范围条件：<、>、<=、>= 和 between 等。

在实际开发中，将范围查询条件防止语句最后，建索引时，也将该字段放置在最后。

> 应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置 where 语句最后。

#### 2.7 不等于 (!= 或 <>) 索引失效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE `NAME` <> 'abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_name      | NULL | NULL    | NULL | 499086 |    50.15 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
```

#### 2.8 IS NULL 可以使用索引，IS NOT NULL 无法使用索引

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;
+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age_classid_name | idx_age_classid_name | 5       | const |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;
+----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys        | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_age_classid_name | NULL | NULL    | NULL | 499086 |    50.00 | Using where |
+----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+
```

> 结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 ('')。
>
> 拓展：同理，在查询中使用 NOT LIKE 也无法使用索引，到值全表扫描。

#### 2.9 like 以通配符 % 开头索引失效

在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为 %，索引就不会起作用。只有 % 不在第一个位置，索引才会起作用。

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.`name` LIKE 'abc%';
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_name      | idx_name | 63      | NULL |   22 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.`name` LIKE '%abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |    11.11 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
```

> 拓展：Alibaba《Java 开发手册》
>
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

#### 2.10 OR 前后存在非索引的列，索引失效

在 WHERE 字句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。也就是说，OR 前后的两个条件中的列都是索引时，查询中才使用索引。

因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。

```sql
CREATE INDEX idx_age ON student(age);
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classId = 100;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_age       | NULL | NULL    | NULL | 499086 |    11.88 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+

CREATE index idx_cid ON student(classId);
+----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+
| id | select_type | table   | partitions | type        | possible_keys   | key             | key_len | ref  | rows  | filtered | Extra                                     |
+----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+
|  1 | SIMPLE      | student | NULL       | index_merge | idx_age,idx_cid | idx_age,idx_cid | 5,5     | NULL | 10232 |   100.00 | Using union(idx_age,idx_cid); Using where |
+----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+
```

当只在 age 字段上建立索引时，会导致索引失效。如果再给 classId 字段建立索引，此时就可以使用索引。

#### 2.11 数据库和表的字符集统一使用 utf8mb4

统一使用 utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。

#### 2.12 建议

- 对于单列索引，尽量选择针对当前 query 过滤性更好的索引。
- 在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择能够包含当前 query 中的 where 子句中更多字段的索引。
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

总之，书写 SQL 语句时，尽量避免造成索引失效的情况。

### 3. 关联查询优化

#### 3.1 数据准备

```sql
# 分类表
CREATE TABLE IF NOT EXISTS `type`(
	id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  card INT(10) UNSIGNED NOT NULL,
  PRIMARY KEY (id)
);
 
# 图书表
CREATE TABLE IF NOT EXISTS book(
	bookId INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  card INT(10) UNSIGNED NOT NULL,
  PRIMARY KEY (bookId)
);

# 向分类表中插入 20 条记录
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));

# 向图书表中插入 20 条记录
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
```

#### 3.2 采用左外连接

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card; 
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                       |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+

CREATE INDEX x ON book(card);
+----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL                 |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | book  | NULL       | ref  | x             | x    | 4       | mysql_test.type.card |    2 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+

CREATE INDEX y ON `type`(card);
+----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref                  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | index | NULL          | y    | 4       | NULL                 |   20 |   100.00 | Using index |
|  1 | SIMPLE      | book  | NULL       | ref   | x             | x    | 4       | mysql_test.type.card |    2 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+
```

#### 3.3 采用内连接

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON type.card = book.card; 
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                       |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |    10.00 | Using where; Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+

CREATE INDEX y ON `type`(card);
+----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL                 |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | type  | NULL       | ref  | y             | y    | 4       | mysql_test.book.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+

CREATE INDEX x ON book(card);
+----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref                  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+
|  1 | SIMPLE      | book  | NULL       | index | x             | x    | 4       | NULL                 |   20 |   100.00 | Using index |
|  1 | SIMPLE      | type  | NULL       | ref   | y             | y    | 4       | mysql_test.book.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+
```

从上述可以得出一下结论：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表。如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。**当表的连接条件中都没有索引 (或都有索引) 时，数据小的表驱动数据大的表**。

#### 3.4 JOIN 语句原理

JOIN 方式连接多表，本质就是各个表之间数据的循环匹配。MySQL5.5 版本之前，MySQL 只支持一种表间关联方式，就是嵌套循环。如果关联表的数据量很大，则 JOIN 关联的执行时间会非常长。在 MySQL 5.5 以后的版本中，MySQL 通过引入 BNLJ 算法来优化嵌套执行。

**驱动表和被驱动表**

驱动表就是主表，被驱动表就是从表、非驱动表。

- 对于内连接来说：

    ```sql
    SELECT * FROM A JOIN B ON ...
    ```

  对于内连接来说 A 不一定是驱动表，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过 explain 关键字可以查看。

- 对于外连接来说：

    ```sql
    SELECT * FROM A LEFT JOIN B ON ...
    或
    SELECT * FROM B RIGHT JOIN A ON ...
    ```

  通常，会认为 A 就是驱动表，B 就是被驱动表。但也未必。 对于外连接来说，查询优化器可能会将外连接修改为内连接，对于内连接，主从表就会不确定。

**简单嵌套循环连接 (Simple Nested-Loop Join)**

算法相当简单，从表 A 中取出一条数据 1，遍历表 B，将匹配到的数据放到 result..以此类推，驱动表 A 中的每一条记录与被驱动表 B 的记录进行判断：

![简单嵌套循环连接](/mysql/简单嵌套循环连接.png)

可以看到这种方式效率是非常低的，以上述表 A 数据 100 条，表 B 数据 1000 条计算，则 A * B = 10 万次。开销统计如下：

| 开销统计         | SNLJ      |
| ---------------- | --------- |
| 外表扫描次数     | 1         |
| 内表扫描次数     | A         |
| 读取记录数       | A + B * A |
| JOIN 比较次数    | A * B     |
| 回表读取记录次数 | 0         |

当然 MySQL 不会这么粗暴的区进行表的连接，所以就出现了后面的两种对 Nested-Loop Join 优化算法。

**索引嵌套循环连接 (Index Nested-Loop Join)**

Index Nested-Loop Join 其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去比较，这样极大的减少了对内层表的匹配次数。

![索引嵌套循环连接](/mysql/索引嵌套循环连接.png)

驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用记录数少的表作为驱动表。

| 开销统计         | SNLJ      | INLJ                  |
| ---------------- | --------- | --------------------- |
| 外表扫描次数     | 1         | 1                     |
| 内表扫描次数     | A         | 0                     |
| 读取记录数       | A + B * A | A + B(match)          |
| JOIN 比较次数    | A * B     | A * Index(Height)     |
| 回表读取记录次数 | 0         | B(match)(if possible) |

如果被驱动表家索引，效率是非常高的，但如果索引不是主键索引，所以还的进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。

**块嵌套循环连接 (Block Nested-Loop Join)**

如果存在索引，那么会使用 index 的方式进行 join，如果 join 的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO 的次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。

不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列 (大小受 join buffer 的限制) 缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配 (内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。

> 注意：
>
> 这里缓存的不只是关联表的列，select 后面的列也会缓存起来。
>
> 在一个有 N 个 join 关联的 SQL 中会分配 N - 1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以让 join buffer 中可以存放更多的列。

![块嵌套循环连接](/mysql/块嵌套循环连接.png)

| 开销统计         | SNLJ      | INLJ                  | BNLJ                                              |
| ---------------- | --------- | --------------------- | ------------------------------------------------- |
| 外表扫描次数     | 1         | 1                     | 1                                                 |
| 内表扫描次数     | A         | 0                     | A * used_column_size / join_buffer_size + 1       |
| 读取记录数       | A + B * A | A + B(match)          | A + B * (A * used_column_size / join_buffer_size) |
| JOIN 比较次数    | B * A     | A * Index(Height)     | B * A                                             |
| 回表读取记录次数 | 0         | B(match)(if possible) | 0                                                 |

参数设置：

- block_nested_loop

  通过 `show variables like '%optimizer_switch%'` 查看 `block_nested_loop` 状态。默认是开启的。

- join_buffer_size

  驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 `join_buffer_size=256k`。

    ```sql
    show variables like '%join_buffer%';
    +------------------+--------+
    | Variable_name    | Value  |
    +------------------+--------+
    | join_buffer_size | 262144 |
    +------------------+--------+
    ```

  Join_buffer_size 的最大值在 32 位系统可以申请 4G，而在 64 位操作系统下可以申请大于 4G 的 Join Buffer 空间 (64 位 Windows 除外，其大值会被截断位 4GB 并发出警告)。

**Join 小结**

- 整体效率比较：INLJ > BNLJ > SNLJ

- 永远用小结果集驱动大结果集 (其本质就是减少外层循环的数据数量) (小的度量单位指的是表行数 * 每行大小)

    ```sql
    select t1.b, t2.* from t1 straight_join t2 on (t1.b = t2.b) where t2.id <= 100;  # 推荐
    select t1.b, t2.* from t2 straight_join t1 on (t1.b = t2.b) where t2.id <= 100;  # 不推荐
    ```

- 为被驱动表匹配的条件增加索引 (减少内层表的循环匹配次数)

- 增大 join buffer size 的大小 (一次缓存的数据越多，那么内层包的扫表次数就越少)

- 减少驱动表不必要的字段查询 (字段越少，join buffer 所缓存的数据就越多)

**Hash Join**

从 MySQL 的 8.0.20 版本开始将废弃 BNLJ，因为从 MySQL 8.0.18 版本开始就加入了 hash join 默认都会使用 hash join

- Nested Loop：

  对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。

- Hash Join 是做大数据集连接时常用方式，优化器使用两个表中较小 (相对较小) 的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。

    - 这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。
    - 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能。
    - 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接 (如 WHERE a .col1 = b.col2)，这是由 Hash 的特点决定的。

  | 类别     | Nested Loop                                                  | Hash Join                                                    |
      | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 使用条件 | 任何条件                                                     | 等值连接 (=)                                                 |
  | 相关资源 | CPU、磁盘 I/O                                                | 内存、临时空间                                               |
  | 特点     | 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。 | 当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高 |
  | 缺点     | 当索引失去或者查询条件限制不够时，效率很低；当表的记录数多时，效率低。 | 为建立哈希表，需要大量内存。第一次的结果返回较慢。           |


#### 3.5 小结

- 保证被驱动表的 JOIN 字段已经创建了索引
- 需要 JOIN 的字段，数据类型保持绝对一致
- LEFT JOIN 时，选择小表作为驱动表，大表作为被驱动表。减少外层循环的次数。
- INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表。选择相信 MySQL 优化策略。
- 能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)
- 不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询或使用 JOIN 来代替子查询。
- 衍生表建不了索引

### 4. 子查询优化

MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，记一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作。

子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：

- 执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。
- 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，索引查询性能会受到一定的影响。
- 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

在 MySQL 中，可以使用连接 (JOIN) 查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。

> 尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代。

### 5. 排序优化

**问题**：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？

在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。

- Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。
- FileSort 排序规则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。

**优化建议**：

- SQL 中。可以在 WHERE 字句和 ORDER BY 字句中使用索引，目的是在 WHERE 字句中避免全表扫描，在 ORDER BY 字句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
- 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。
- 无法使用 Index 时，需要对 FileSort 方式进行调优。

**测试**

先删除 student 和 class 表创建的索引。`CALL proc_drop_index('mysql_test', 'student')`、`CALL proc_drop_index('mysql_test', 'class')`

```sql
# 创建索引
CREATE INDEX idx_age_classId_name ON student (age, classId, name);
# ORDER BY 时不 LIMIT，索引失效
EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age, classId;
EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age, classId LIMIT 10;

# ORDER BY 时顺序错误，索引失效
CREATE INDEX idx_age_classId_stuno ON student (age, classId, stuno);
EXPLAIN SELECT * FROM student ORDER BY classId LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY classId, `NAME` LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age, classId, stuno LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age, classId LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age LIMIT 10;

# ORDER BY 时规则不一致，索引失效 (顺序错，不索引；方向反，不索引)
EXPLAIN SELECT * FROM student ORDER BY age DESC, classId ASC LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY classId DESC, `NAME` DESC LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age ASC, classId DESC LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age DESC, classId DESC LIMIT 10;

# 无过滤，不索引
EXPLAIN SELECT * FROM student WHERE age = 45 ORDER BY classId;
EXPLAIN SELECT * FROM student WHERE age = 45 ORDER BY classId, `NAME`;
EXPLAIN SELECT * FROM student WHERE classId = 45 ORDER BY age;
EXPLAIN SELECT * FROM student WHERE classId = 45 ORDER BY age LIMIT 10;
```

**小结**

```sql
INDEX a_b_c(a, b, c)
order by 能使用索引最左前缀
- ORDER BY a
- ORDER BY a, b
- ORDER BY a, b, c
- ORDER BY a DESC, B DESC, c DESC

如果 WHERE 使用索引的最左前缀定义为常量，则 order by 能使用索引
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b= const ORDER BY c
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b > const ORDER BY b, c

不能使用索引进行排序
- ORDER BY a ASC, b DESC, c DESC	# 排序不一致
- WHERE g = const ORDER BY b, c		# 丢失 a 索引
- WHERE a = const ORDER BY c 		# 丢失 b 索引
- WHERE a = const ORDER BY a, d		# d 不是索引的一部分
- WHERE a IN (...) ORDER BY b, c		# 对于排序来说，多个相等条件也是范围查询
```

**实战**

清空索引。查询年龄为 30 岁的，且学生编号小雨 101000 的学生，按用户名称排序

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY `NAME`; 
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |     3.33 | Using where; Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+
```

结果是 type 为 ALL，Extra 还出现了 Using FIleSort，都是最坏的情况。所以必须优化。

**方案一：为了去掉 filesort 可以把所有建成**

```sql
CREATE INDEX idx_age_name ON student(age, NAME);
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY `NAME`; 
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age_name  | idx_age_name | 5       | const | 18544 |    33.33 | Using where |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+
```

**方案二：尽量让 WHERE 的过滤条件和排序使用上索引**

```sql
# 建立一个三个字段的组合索引
CREATE INDEX idx_age_stuno_name ON student (age, stuno, NAME);
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY `NAME`; 
+----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table   | partitions | type  | possible_keys                   | key                | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_age_name,idx_age_stuno_name | idx_age_stuno_name | 9       | NULL |   19 |   100.00 | Using index condition; Using filesort |
+----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+
```

现在发现 Using FileSort 依然存在，索引 name 并没有使用到索引，而且 type 还是 range，光看字面其实并不美好。原因是，因为 stuno 是一个范围过滤，所以索引后面的字段不会再使用索引了。

结果竟然有 filesort 的 SQL 运行速度，超过了已经优化掉 filesort 的 SQL，而且快了很多，几乎一瞬间就出现了结果。

原因：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对 stuno < 101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这时非常消耗性能的，索引放在这个字段上性价比最高，是最优选择。

> 结论：
>
> - 两个索引同时存在，MySQL 自动选择最优方案。 (对于这个例子，MySQL 选择 idx_age_stuno_name)。但是，随着数据量的变化 ，选择的索引也会随之变化的。
> - 当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。

**FileSort 算法**

排序的字段如果不在索引列上，则 FileSort 会有两种算法：双路排序和单路排序

- 双路排序 (慢)

  MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘去排序字段，在 buffer 进行排序，再从磁盘去其他字段。取一批数据，要对磁盘进行两次扫描，总所周知，IO 是很耗时的，索引在 MySQL 4.1 之后，出现了第二种改进的算法，就是单路排序。

- 单路排序 (快)

  从磁盘读取查询需要的所有列，按照order by 列在 buffer 对他们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。

**结果及引申出的问题**

- 由于单路是后出，总体而言好过双路
- 但是用单路有问题
    - 在 sort_buffer 中，单路比多路要多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序 (创建 tmp 文件，多路合并)，排完再取 sort_buffer 容量大小，再排......从而多次 I/O。
    - 单路本来想省一次 I/O 操作，反而 导致了大量的 I/O 操作，反而得不偿失。

**优化策略**

- 尝试提高 sort_buffer_size

  不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程 (connection) 的 1M-8M 之间调整。MySQL 5.7，InnoDB 存储引擎默认值是 1048576 字节，1MB。

    ```sql
    SHOW VARIABLES LIKE '%sort_buffer_size%';
    +-------------------------+---------+
    | Variable_name           | Value   |
    +-------------------------+---------+
    | innodb_sort_buffer_size | 1048576 |
    | myisam_sort_buffer_size | 8388608 |
    | sort_buffer_size        | 262144  |
    +-------------------------+---------+
    ```

- 尝试提高 max_length_for_sort_data

  提高这个参数，会增加用改进算法的概率。

    ```sql
    SHOW VARIABLES LIKE '%max_length_for_sort_data%';		# 默认 1024 字节
    ```

  但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192 字节之间调整。

- ORDER BY 时 SELECT * 是一个大忌。最好只 QUERY 需要的字段。

  当 QUERY 的字段大小总和小于 max_length_for_sort_data，而且排序字段不是 TEXT｜BLOB 类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。

  两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险风大一些，所以要提高 sort_buffer_size。

### 6.GROUP BY 优化

- group by 使用索引的原则几乎跟 order by 一致，group by 即使没有过滤条件使用到索引，也可以直接使用索引。
- group by 先排序再分组，遵照索引建的最佳左前缀原则
- 当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置
- where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了
- 减少使用 order by，和业务沟通能不排序就不排序，或将排序当道程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的
- 包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢

### 7. 优化分页查询

一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000，10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。

```sql
EXPLAIN SELECT * FROM student LIMIT 2000000, 10;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+
```

**优化思路一**

在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。
```sql
EXPLAIN SELECT * FROM student t, (SELECT id FROM student ORDER BY id LIMIT 2000000, 10) a WHERE t.id = a.id;
+----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 499086 |   100.00 | NULL        |
|  1 | PRIMARY     | t          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | a.id |      1 |   100.00 | NULL        |
|  2 | DERIVED     | student    | NULL       | index  | NULL          | PRIMARY | 4       | NULL | 499086 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
```

**优化思路二**

该方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询。

```sql
EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |   100.00 | Using where |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```

### 8. 优先考虑覆盖索引

#### 8.1 什么是覆盖索引

- 索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。**一个索引包含了满足查询结果的数据就叫做覆盖索引**。
- 非聚簇复合索引的一种方式，它包括在查询里的 SELECT、JOIN 和 WHERE 子句用到的所有列 (即建索引的字段正好是覆盖查询条件中所涉及的字段)。简单说就是，`索引列 + 主键` 包含 `SELECT 到 FROM 之间查询的列`。

  举例：

```sql
# 删除原有索引并创建新索引
CREATE INDEX idx_age_name ON student(age, `NAME`);
EXPLAIN SELECT * FROM student WHERE age <> 20;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_age_name  | NULL | NULL    | NULL | 499086 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+

EXPLAIN SELECT age, `NAME` FROM student WHERE age <> 20;
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | student | NULL       | index | idx_age_name  | idx_age_name | 68      | NULL | 499086 |   100.00 | Using where; Using index |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+

mysql> EXPLAIN SELECT * FROM student WHERE `NAME` LIKE '%abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |    11.11 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+

mysql> EXPLAIN SELECT id, age FROM student WHERE `NAME` LIKE '%abc';
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | student | NULL       | index | NULL          | idx_age_name | 68      | NULL | 499086 |    11.11 | Using where; Using index |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
```

#### 8.2 覆盖索引的利弊

好处：

- 避免 InnoDB 表进行索引的二次查询 (回表)

  InnoDB 是以聚簇索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。

- 可以把随机 IO 变成顺序 IO 加快查询效率

  由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少得多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**。

弊端：

- 索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者成为业务数据架构师的工作。

### 9. 如何给字符串添加索引

### 10. 索引下推

#### 10.1 使用前后对比

Index Condition Pushdown (ICP) 是 MySQL 5.6 中新特性，是一种在存储引擎层使用过滤数据的优化方式。

- 如果没有 ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给 MySQL 服务器，由 MySQL 服务器评估 WHERE 后面的条件是否保留行。
- 启用 ICP 后，如果部分 WHERE 条件可以仅使用索引中的列进行筛选，则 MySQL 服务器会把这部分 WHERE 条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。
    - 好处：ICP 可以减少存储引擎必须访问基表的次数和 MySQL 服务器必须访问存储引擎的次数。
    - 但是，ICP 的加速效果取决于在存储引擎内通过 ICP 筛选掉的数据的比例。

#### 10.2 ICP 的开启/关闭

- 默认情况下启用索引条件下推。可以通过设置系统变量 optimizer_switch 控制：`index_condition_pushdown`

```sql
# 打开索引下推
SET optimizer_switch = 'index_condition_pushdown=on';
# 关闭索引下推
SET optimizer_switch = 'index_condition_pushdown=off';
```

- 当使用索引条件下推时，EXPLAIN 语句输出结果中 Extra 列内容显示为 `Using index condition`。

#### 10.3 ICP 使用案例

```sql
# 建表
CREATE TABLE people (
	id INT NOT NULL AUTO_INCREMENT,
	zipcode VARCHAR ( 20 ) COLLATE utf8_bin DEFAULT NULL,
	firstname VARCHAR ( 20 ) COLLATE utf8_bin DEFAULT NULL,
	lastname VARCHAR ( 20 ) COLLATE utf8_bin DEFAULT NULL,
	address VARCHAR ( 50 ) COLLATE utf8_bin DEFAULT NULL,
	PRIMARY KEY ( id ),
KEY zip_last_first ( zipcode, lastname, firstname ) 
) ENGINE = INNODB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8mb3 COLLATE = utf8_bin;

# 插入数据
INSERT INTO people VALUES
('1','000001', '三', '赵', '北京市'),
('2','000002', '四', '钱', '重庆市'),
('3','000003', '五', '孙', '南京市'),
('4','000004', '六', '李', '天津市');


# 知道一个人邮编，但是不确定这个人的姓氏
EXPLAIN SELECT * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%' AND address LIKE '%北京市%';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra                              |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+
|  1 | SIMPLE      | people | NULL       | ref  | zip_last_first | zip_last_first | 63      | const |    1 |    25.00 | Using index condition; Using where |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+
```

执行查看 SQL 的查询计划，Extra 中显示了 Using index condition，这表示使用了索引下推。另外，Using where 表示条件中包含需要过滤的非索引列数据，即 `address LIKE '%北京市%'` 这个条件并不是索引列，需要在服务端过滤掉。如果不想出现 Using where，把 `address LIKE '%北京市%'` 去掉即可。

#### 10.4 开启和关闭 ICP 的性能对比

创建存储过程，主要目的就是插入很多 000001 的数据，这样查询的时候为了在存储引擎层做过滤，减少 IO，也为了减少缓冲池 (缓存数据页，没有 IO) 的作用。

```sql
DELIMITER //
CREATE PROCEDURE insert_people(max_num INT)
BEGIN
DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
	SET i = i + 1;
	INSERT INTO people (zipcode, firstname, lastname, address) VALUES ('000001', '六', '周', '天津市');
	UNTIL i = max_num
	END REPEAT;
	COMMIT;
END //
DELIMITER ;

# 调用存储过程
CALL insert_people(1000000);

# 打开 profiling
set profiling = 1;

# 执行 SQL 语句，此时默认打开索引下推
SELECT * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%';

# 再次执行 SQL 语句，不使用索引下推
SELECT /*+ no_icp (people) */ * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%';

# 查看当前会话所产生的所有 profiles
SHOW profiles;
+----------+------------+------------------------------------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                                                          |
+----------+------------+------------------------------------------------------------------------------------------------+
|        1 | 0.17796400 | SELECT * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%'                         |
|        2 | 1.06563900 | SELECT /*+ no_icp (people) */ * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%'  |
+----------+------------+------------------------------------------------------------------------------------------------+

SHOW profile FOR query 1;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000193 |
| Executing hook on transaction  | 0.000006 |
| starting                       | 0.000015 |
| checking permissions           | 0.000011 |
| Opening tables                 | 0.000314 |
| init                           | 0.000011 |
| System lock                    | 0.000019 |
| optimizing                     | 0.000024 |
| statistics                     | 0.000226 |
| preparing                      | 0.000046 |
| executing                      | 0.177033 |
| end                            | 0.000014 |
| query end                      | 0.000003 |
| waiting for handler commit     | 0.000008 |
| closing tables                 | 0.000008 |
| freeing items                  | 0.000021 |
| cleaning up                    | 0.000012 |
+--------------------------------+----------+

SHOW profile FOR query 1;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.001877 |
| Executing hook on transaction  | 0.000012 |
| starting                       | 0.000015 |
| checking permissions           | 0.000008 |
| Opening tables                 | 0.000120 |
| init                           | 0.000007 |
| System lock                    | 0.000015 |
| optimizing                     | 0.000030 |
| statistics                     | 0.000195 |
| preparing                      | 0.000041 |
| executing                      | 1.063250 |
| end                            | 0.000015 |
| query end                      | 0.000004 |
| waiting for handler commit     | 0.000008 |
| closing tables                 | 0.000006 |
| freeing items                  | 0.000025 |
| cleaning up                    | 0.000011 |
+--------------------------------+----------+
```

多次测试效率对比来看，使用 ICP 优化的查询效率会好一些。这里建议多存储一些数据效果更明显。

#### 10.5 ICP 的使用条件

- 如果表访问的类型为 range、ref、eq_ref 和 ref_or_null 可以使用 ICP
- ICP 可以用于 InnoDB 和 MyISAM 表，包括分区表 InnoDB 和 MyISAM 表
- 对于 InnoDB 表，ICP 仅用于二级索引。ICP 的目标是减少全行读取次数，从而减少 I/O 操作。
- 当 SQL 使用覆盖索引时，不支持 ICP。因为这种情况下使用 ICP 不会减少 I/O。
- 相关子查询的条件不能使用 ICP。

### 11. 其他查询优化策略

#### 11.1 EXISTS 和 IN 的区分

**问题**：

不太理解那种情况下应该使用 EXISTS，哪种情况下应该用 IN。选择的标准是看能否使用表的索引吗？

**回答**：

索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。

比如下面这样：

```sql
SELECT * FROM A WHERE cc IN (SELECT cc FROM B);
SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc = A.cc);
```

当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：

```sql
for i in A
	for j in B
		if j.cc == i.cc then ...
```

当 B 小于 A 时用 IN，因为实现的逻辑类似于：

```sql
for i in B
	for j in A
		if j.cc == i.cc then ...
```

哪个表小就用哪个表来驱动，A 表小就用 EXISTS，B 表小就用 IN。

#### 11.2 COUNT(*) 与 COUNT(具体字段) 效率

**问提**：

在 MySQL 中统计数据表的行数，可以使用三种方式：`SELECT COUNT(*)`、`SELECT COUNT(1)` 和 `SELECT COUNT(具体字段)`，使用这三者之间的查询效率是怎样的？

**回答**：

前提：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。

- COUNT(*) 和 COUNT(1) 都是对所有结果进行 COUNT，COUNT(\*) 和 COUNT(1) 本质上并没有区别 (二者执行时间可能略有差别，不过还是可以把它两的执行效率看成是相等的)。如果有 WHERE 字句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 字句，则是对数据表的数据行数进行统计。
- 如果是 MyISAM 存储引擎，统计数据表的行数只需要 O(1) 的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。如果是 InnoDB 存储引擎，因为 InnoDB 支持事物，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用扫描全表，是 O(n) 的复杂度，进行循环 + 计数的方式来完成统计。
- 在 InnoDB 存储引擎中，如果采用 COUNT(具体字段) 来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引 (非聚簇索引)。对于 COUNT(*) 和 COUNT(1) 来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

#### 11.3 关于 SELECT(*)

在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用 SELECT <字段列表> 查询。原因：

- MySQL 在解析的过程中，会通过查询数据字典将 * 按序转换成所有列名，这会大大的耗费资源和时间。
- 无法使用覆盖索引。

#### 11.4 LIMIT 1 对优化的影响

针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。

如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。

#### 11.5 多使用 COMMIT

只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。

COMMIT 所释放的资源：

- 回滚段上用于恢复数据的信息
- 被程序语句获得的锁
- redo / undo log buffer 中的空间
- 管理上述三种资源中的内部花费

### 12. 淘宝数据库，主键如何设计的？

数据库的主键如何设计，大多数人的回答都会是用 8 字节的 BIGINT 做主键，而不要用 INT。(错)

这样的回答，只站在了数据库着一层，而没有从业务的角度思考主键。主键就是自增 ID 吗？用自增做主键，架构设计上可能连及格都拿不到。

#### 12.1 自增 ID 的问题

自增 ID 做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增 ID 除了简单其他都是缺点，总体来看存在以下几方面的问题：

- 可靠性不高

  存在自增 ID 回溯的问题，这个问题直到最新版本的 MySQL 8.0 才修复

- 安全性不高

  对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/ 这样的接口，可以非常容易猜测用户 ID 的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。

- 性能差

  自增 ID 的性能较差，需要在数据库服务器端生成。

- 交互多

  业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条 SQL，就多一次性能上的开销。

- 局部唯一性

  最重要的一点，自增 ID 是局部唯一，只在当前数据库实例中唯一，而不是全剧唯一，在任意服务期间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。

#### 12.2 业务字段做主键

为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。考虑业务字段做主键。

| cardno   | name | phone       | pid                 | address | sex  | birthday   |
| -------- | ---- | ----------- | ------------------- | ------- | ---- | ---------- |
| 10000001 | 张三 | 13300000001 | 1101232000000007890 | 上海    | 女   | 2000-01-02 |
| 10000002 | 李四 | 13300000002 | 1101232000000007891 | 浙江    | 男   | 1999-02-03 |

- 选择卡号 (cardno)

  会员卡号看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。

    ```sql
    CREATE TABLE demo.membermaster(
    	cardno CHAR(8) PRIMARY KEY,
      name TEXT,
      phone TEXT,
      pid TEXT,
      address TEXT,
      sex TEXT,
      birthday DATETIME
    );
    ```

  不同的会员卡号对应不同的会员，字段 cardno 唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。

  但实际情况是，会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 (退还了会员卡)，于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号 10000001 的会员卡发给了王五。

  从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是 10000001 这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是 10000001 的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现有的模块获取到修改之前的会员信息，有些模块获取到修改后的会员信息，而导致系统内部数据不一致的情况。因此，从信息系统层面上看是没问题的。

  但是从使用系统的业务层面来看，就有很大的问题了，会对商家造成影响。

  比如，有一个销售流水表 (trans)，记录了所有的销售流水明细。2020-12-01，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：

  | transactionno | itemnumber | quantity | price | salesvalue | cardno   | transdate  |
      | ------------- | ---------- | -------- | ----- | ---------- | -------- | ---------- |
  | 1             | 1          | 1        | 89    | 89         | 10000001 | 2020-12-01 |

  接着，查询一下2020-12-01 的会员消费记录：

    ```sql
    SELECT b.name, c.goodsname, a.quantity, a.salesvalue, a.transdate
    FROM demo.trans AS a
    JOIN demo.membermaster AS b
    JOIN demo.goodsmaster AS c
    ON (a.cardno = b.cardno AND a.itemnumber = c.itemnumber);
    ```

  如果会员卡 10000001 又发给了王五，我们会更改会员信息表。到值查询时得到的结果是王五在 2020-12-01 买了一本书，消费 89 元。所以不能将会员卡好当做主键。

- 选择会员电话或身份证号

  会员电话可以做主键吗？不行的。在实际操作中，手机号也存在被运营商收回，重新发给别人用的情况。

  那身份证号行不行呢？好像可以，因为身份证绝不会重复，身份证号与一个人存在一一对应的关系。可问题是，身份证号属于个人隐私，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。

  **所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现**。

  > 经验：
  >
  > 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。

#### 12.3 淘宝的主键设计

打开自己淘宝订单，会发现每个订单号的特征。例如：1713216900604568394、1696231922773568394

可以发现，订单号不是自增 ID。订单号长度为 19 位，且订单号的最后 6 位都是一样的，都是568394。且订单号的前面 13 位部分是单调递增的。

大胆猜测，淘宝的订单 ID 设计应该是：`订单 ID = 时间 + 去重字段 + 用户ID后6位尾号`。这样的设计能做到全剧唯一，且对分布式系统查询及其友好。

#### 12.4 推荐的主键设计

非核心业务：对应表的主键自增 ID，如告警、日志、监控等信息。

核心业务：**主键设计至少应该是全局唯一且是单调递增**。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。

这里推荐最简单的一种主键设计：UUID

**UUID 的特点**：

全局唯一，占用 36 字节，数据无序，插入性能差。

**认识 UUID**：

- 为什么 UUID 是全局唯一的？
- 为什么 UUID 占用 36 个字节？
- 为什么 UUID 是无序的？

MySQL 数据库的 UUID 组成如下所示：

```sql
UUID = 时间 + UUID版本(16字节) - 时钟序列(4字节) - MAC地址(12字节)
```

![mysql-uuid](/mysql/mysqluuid.png)

**为什么 UUID 是全局唯一的**？

在 UUID 中的时间部分占用 60 位，存储的类似 TIMESTAMP 的时间戳，但表示的是从 1582-10-15 00:00:00.00 到现在的 100ns 的计数。可以看到 UUID 存储的时间精度比 TIMESTAMP 更高，时间维度发生重复的概率降低到 1/100ns。

时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC 地址用于全局唯一。

**为什么 UUID 占用 36 字节**？

UUID 根据字符串进行存储，设计时还带有无用的 “-” 字符串，因此总共需要 36 字节。

**为什么 UUID 是随机无序的呢**？

因为 UUID 的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。

**改造 UUID**

若将时间高低位互换，则时间就是单调递增的了，也就变的单调递增了。MySQL 8.0 可以更换时间低位和时间高位的存储方式，这样 UUID 就是有序的 UUID 了。

MySQL 8.0 还解决了 UUID 存在的空间占用的问题，除去了 UUID 字符串中无意义的 ”-“ 字符串，并且将字符串用二进制类型保存，这样存储空间降低为了 16 字节。

可以通过 MySQL 8.0 提供的 uuid_to_bin 函数实现上述功能，同样的，MySQL 也提供了 bin_to_uuid 函数进行转化：

```sql
SET @uuid = UUID();
SELECT @uuid, uuid_to_bin(@uuid), uuid_to_bin(@uuid, TRUE);
```

**通过函数 uuid_to_bin(@uuid, true) 将 UUID 转化为有序 UUID**了。全局唯一 + 单调递增。

**有序 UUID 性能测试**

16 字节的有序 UUID，相比之前 8 字节的自增 ID，性能和存储空间对比究竟如何呢？

插入 1 亿条数据，每条数据占用 500 字节，含有 3 个二级索引，最终的结果如下所示：

![有序uuid性能测试](/mysql/有序uuid性能测试.png)

从上图可以看到插入 1 亿条数据有序 UUID 是最快的，而且在实际业务使用中有序 UUID 在业务端就可以生成。还可以进一步减少 SQL 交互次数。

另外，虽然有序 UUID 相比自增 ID 多了 8 个字节，但是鸡只增大了 3g 的存储空间，还可以接受。

> 在当今的互联网环境中，非常不推荐自增 ID 作为主键的数据库设计。更推荐类似有序 UUID 的全局唯一的实现。
>
> 另外，在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。

**如果不是 MySQL 8.0 怎么办**？

手动赋值字段做主键！

比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。

可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。