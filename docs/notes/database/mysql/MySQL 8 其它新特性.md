---
title: MySQL 8 其它新特性
createTime: 2024/12/19 14:07:45
permalink: /database/t7v7ivoz/
---

### 1. MySQL 8 新特性概述

`MySQL 从 5.7 版本直接跳跃发布了 8.0 版本`，可见这是一个令人兴奋的里程碑版本。MySQL 8 版本在功能上做了显著的改进与增强，开发者对 MySQL 的源代码进行了重构，最突出的一点是多 MySQL Optimizer 优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。

#### 1.1 MySQ L 8.0 新增特性

- 更简便的 NoSQL 支持

  NoSQL 泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从 5.6 版本开始，MySQL 就开始支持简单的 NoSQL 存储功能。MySQL 8 对这一功能做了优化，以更灵活的方式实现 NoSQL 功能，不再依赖模式 (schema)。

- 更好的索引

  在查询中，正确地使用索引可以提高查询的效率。MySQL 8 中新增了隐藏索引和降序索引。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。

- 更完善的 JSON 支持

  MySQL 从 5.7 开始支持原生 JSON 数据的存储，MySQL 8 对这一功能做了优化，增加了聚合函数 `JSON_ARRAYAGG()` 和 `JSON_OBJECTAGG()`，将参数聚合为 JSON 数组或对象，新增了行内操作符 ->>，是列路径运算符 -> 的增强，对 JSON 排序做了提升，并优化了 JSON 的更新操作。

- 安全和账户管理

  MySQL 8 中新增了 `caching_sha2_password` 授权插件、角色、密码历史记录和 FIPS 模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够灵活地进行账户管理工作。

- InnoDB 的变化

  `InnoDB 是 MySQL 默认的存储引擎`，是事物型数据库的首选引擎，支持事物安全表 (ACID)，支持行锁定和外键。在 MySQL 8 版本中，InnoDB 在自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言 (DDL)，提高了数据安全性，对事物提供更好的支持。

- 数据字典

  在之前的 MySQL 版本中，字典数据都存储在原数据文件和非事物表中。从 MySQL 8 开始新增了事物数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。

- 原子数据定义语句

  MySQL 8 开始支持原子数据定义语句 (Automic DDL)，即 原子 DDL。目前，只有 InnoDB 存储引擎支持原子 DDL。原子数据定义语句 (DDL) 将与 DDL 操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事物中，这是的即使服务器崩溃，事物也会提交或回滚。

  使用支持原子操作的存储引擎所创建的表，在执行 `DROP TABLE`、`CREATE TABLE`、`ALTER TABLE`、`RENAME TABLE`、`TRUNCATE TABLE`、 `CREATE TABLESPACE`、`DROP TABLESPACE` 等操作时，都支持原子操作，即事物要么完全操作成功，要么失败后回滚，不再进行部分提交。

  对于 MySQL 5.7 复制到 MySQL 8 版本中的语句，可以添加 `IF EXITST` 或 `IF NOT EXITST` 语句来避免发生错误。

- 资源管理

  MySQL 8 开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。

  目前，CPU 时间是可控资源，由“虚拟 CPU” 这个概念来表示，此术语包含 CPU 的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟 CPU 数量。拥有对应权限的数据库管理员可以将这些 CPU 与资源组关联，并为资源组分配线程。

  资源组组件为 MySQL 中的资源组管理提供了 SQL 接口。资源组的属性用于定义资源组。MySQL 中存在两个默认组， 系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。

  在一些平台下，或进行了某些 MySQL 的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是 macOS 系统，资源管理将处于不可用状态。在 FreeBSD 和 Solaris 系统中，资源线程优先级将失效。在 Linux 系统中，只有配置了 CAP_SYS_NICE 属性，资源管理优先级才能发挥作用。

- 字符集支持

  MySQL 8 中默认的字符集由 latin1 更改为 utf8mb4，并首次增加了日语所特定使用的集合，`utf8mb4_ja_0900_as_cs`。

- 优化器增强

  MySQL 优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。

- 公用表表达式

  公用表表达式 (Common Table Expressions) 简称 CTE，MySQL 现在支持递归和非递归两种形式的 CTE。CTE 通过在 SELECT 语句或其他特定语句前使用 WITH 语句对临时结果集进行命名。

  基础语法如下：

    ```sql
    WITH cte_name (col_name1, col_name2 ...) AS (Subquery)
    SELECT * FROM cte_name;
    ```

  Subquery 代表子查询，子查询前使用 WITH 语句将结果集命名为 cte_name，在后续的查询中即可使用 cte_name 进行查询。

- 窗口函数

  MySQL 8 开始支持窗口函数。在之前的版本中已存在的大部分聚合函数在 MySQL 8 中也可以作为窗口函数来使用。

  | 函数名称       | 描述                                                     |
      | -------------- | -------------------------------------------------------- |
  | CUME_DIST()    | 累计的分布值                                             |
  | DENSE_RANK()   | 对当前记录不间断排序                                     |
  | FIRST_VALUE()  | 返回窗口首行记录的对应字段值                             |
  | LAG()          | 返回对应字段的前 N 行记录                                |
  | LAST_VALUE()   | 返回窗口尾行记录的对应字段值                             |
  | LEAD()         | 返回对应字段的后 N 行记录                                |
  | NTH_VALUE()    | 返回第 N 条记录对应的字段值                              |
  | NTILE()        | 将区划分为 N 组，并返回组的数量                          |
  | PERCENT_RANK() | 返回 0 到 1 之间的小数，表示某个字段值在数据分区中的排名 |
  | RANK()         | 返回分区内每条记录对应的排名                             |
  | ROW_NUMBER()   | 返回每一条记录对应的序号，且不重复                       |

- 正则表达式支持

  MySQL 在 8.0.4 以后的版本中采用支持 Unicode 的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的 Unicode 支持，而且是多字节安全编码。MySQL 增加了 `REGEXP_LIKE()`、`EGEXP_INSTR()`、`REGEXP_REPLACE()` 和 `REGEXP_SUBSTR()` 等函数来提升性能。另外，regexp_stack_limit 和 regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。

- 内部临时表

  **TempTable 存储引擎取代 MEMORY 存储引擎成为内部临时表的默认存储引擎**。TempTable 存储引擎为 VARCHAR 和 VARBINARY  列提供高效存储。internal_tmp_mem_storage_engine 会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable 和  MEMORY，其中 TempTable 为默认的存储引擎。temptable_max_ram 系统配置项定义了 TempTable 存储引擎可使用的最大内存数量。

- 日志记录

  在MySQL 8 中错误日志子系统由一系列 MySQL 组件构成。这些组件的构成由系统变量 log_error_services 来配置，能够实现日志事件的过滤和写入。

- 备份锁

  新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。

- 增强的 MySQL 复制

  MySQL 8 复制支持对 JSON 文档进行部分更新的二进制日志记录，该记录使用紧凑的二进制格式，从而节省记录完整 JSON 文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的 binlog_row_value_options 系统变量值设置为 PARTIAL_JSON 来启用。

#### 1.2 MySQL 8.0 移除的旧特性

在 MySQL 5.7 版本上开发的应用程序如果使用了 MySLQ 8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。

- 查询缓存

  查询缓存已被移除，删除的项有：

    - 语句：`FLUSH QUERY CACHE` 和 `RESET QUERY CACHE`。
    - 系统变量：`query_cache_limit`、`query_cache_min_res_unit`、`query_cache_size`、`query_cache_type`、`query_cache_wlock_invalidate`。
    - 状态变量：`Cache_free_blocks`、`Cache_free_memory`、`Cache_hits`、`Cache_inserts`、`Cache_lowmen_prunes`、`Cache_not_cached`、`Cache_queries_in_cache`、`Qcache_total_blocks`。
    - 线程状态：`checking privileges on cached query`、`checking query cache for query`、`invalidating query cache entries`、`sending cached result to client`、`storing result in query cache`、`waiting for query cache lock`。

- 加密相关

  删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT() 和 DES_DECRYPT() 函数，配置项 des-key-file，系统变量 have_crypt，FLUSH 语句的 DES_KEY_FILE 选项，HAVE_CRYPT CMake 选项。

  对于移除的 ENCRYPT() 函数，考虑使用 SHA2() 替代，对于其他移除的函数，使用 AES_ENCRYPT() 和 AES_DECRYPT() 替代。

- 空间函数相关

  在 MySQL 5.7 版本中，多个空间函数已被标记为过时。这些过时的函数在 MySQL 8 中都已被移除，只保留了对应的 ST_ 和 MBR 函数。

- \N 和 NULL

  在 SQL 语句中，解析器不再将 \N 视为 NULL，所以在 SQL 语句中应使用 NULL 代替 \N。这项变化不会影响使用 `LOAD DATA INFILE` 或者 `SELECT ... INTO OUTFILE` 操作文件的导入和导出。在这类操作中，NULL 仍等同于 \N。

- mysql_install_db

  在 MySQL 分布中，已移除了 mysql_install_db 程序，数据字典初始化需要调用带着 --initialize 或者 --initialize-insecure 选项的 mysqld 来代替实现。另外，--bootstrap 和 INSTALL_SCRIPTDIR CMake 也已被删除。

- 通用分区处理程序

  通用分区处理程序已从 MySQL 服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。

  提供本地分区支持的 MySQL 存储引擎有两个，即 InnoDB 和 NDB，而在 MySQL 8 中 只支持 InnoDB。

- 系统和状态变量信息

  在 INFORMATION_SCHEMA 数据库中国呢，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS 表都已被删除。另外，系统变量 show_compatibility_56 也已被删除。被删除的状态变量有 Slave_heartbeat_period、slave_last_heartbeat、Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。

- mysql_plugin 工具

  mysql_plugin 工具用来配置 MySQL 服务器插件，现已被删除，可使用 --plugin-load 或 --plugin-load-add 选项在服务器启动时加载插件或者在运行时使用 INSTALL PLUGIN 语句加载插件来替代该工具。

### 2. 窗口函数

#### 2.1 窗口函数分类

MySQL 从 8.0 版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果集合成一条记录，而窗口函数是将结果置于每一条数据记录中。

窗口函数可以分为静态窗口函数和动态窗口函数。

- 静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；
- 动态窗口函数的窗口大小会随着记录的不同而变化。

窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其它函数。

| 函数分类 | 函数                                       | 函数说明                                                     |
| -------- | ------------------------------------------ | ------------------------------------------------------------ |
| 序号函数 | ROW_NUMBER()<br />RANK()<br />DENSE_RANK() | 顺序排序<br />并列排序，会跳过重复的序号，比如序号为1、1、3<br />并列排序，不会跳过重复的序号，比如序号为1、1、2 |
| 分布函数 | PERCENT_RANK()<br />CUME_DIST()            | 等级值百分比<br />累积分布值                                 |
| 前后函数 | LAG(expr, n)<br />LEAD(expr, n)            | 返回当前行的前 n 行的 expr 值<br />返回当前行的后 n 行的 expr 值 |
| 首尾函数 | FIRST_VALUE(expr)<br />LAST_VALUE(expr, n) | 返回第一个 expr 值<br />返回最后一个 expr 值                 |
| 其它函数 | NTH_VALUE(expr, n)<br />NTILE(n)           | 返回第 n 个 expr 值<br />将分区中的有序数据分为 n 个桶，记录桶编号 |

#### 2.2 语法结构

```sql
函数 OVER ([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC])
或
函数 OVER 窗口名 _ WINDOW 窗口名 AS ([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC])
```

- OVER 关键字指定函数窗口的范围。
    - 如果省略后面括号中的内容，则窗口会包含满足 WHERE 条件的所有记录，窗口函数会基于所有满足 WHERE 条件的记录进行计算。
    - 如果 OVER 关键字后面的括号不为空，则可以使用如下语法设置窗口。
- 窗口名：为窗口设置一个别名，用来标识窗口。
- PARTITION BY 子句：指定窗口函数按照哪些字段就行分组。分组后，窗口函数可以在每个分组中分别执行。
- ORDER BY 子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。
- FRAME 子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。

#### 2.3 分类讲解

例子：

```sql
# 创建表
CREATE TABLE goods(
id INT PRIMARY KEY AUTO_INCREMENT,
category_id INT,
category VARCHAR(15),
NAME VARCHAR(30),
price DECIMAL(10,2),
stock INT,
upper_time DATETIME
);

# 添加数据
INSERT INTO goods(category_id, category, NAME, price, stock, upper_time)
VALUES
(1, '女装/女士精品', 'T恤', 39.90, 1000, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '连衣裙', 79.90, 2500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '卫衣', 89.90, 1500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '牛仔裤', 89.90, 3500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '百褶裙', 29.90, 500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '呢绒外套', 399.90, 1200, '2020-11-10 00:00:00'),
(2, '户外运动', '自行车', 399.90, 1000, '2020-11-10 00:00:00'),
(2, '户外运动', '山地自行车', 1399.90, 2500, '2020-11-10 00:00:00'),
(2, '户外运动', '登山杖', 59.90, 1500, '2020-11-10 00:00:00'),
(2, '户外运动', '骑行装备', 399.90, 3500, '2020-11-10 00:00:00'),
(2, '户外运动', '运动外套', 799.90, 500, '2020-11-10 00:00:00'),
(2, '户外运动', '滑板', 499.90, 1200, '2020-11-10 00:00:00');
```

针对 goods 表中的数据来验证每个窗口函数的功能。

- 序号函数 - `ROW_NUMBER()` 函数

  对数据中的序号进行顺序显示。

    ```sql
    # 查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。
    SELECT
    	ROW_NUMBER() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num,
    	id, category_id, category, NAME, price, stock 
    FROM goods;
    # 结果
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    | row_num | id | category_id | category            | NAME            | price   | stock |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    |       1 |  6 |           1 | 女装/女士精品       | 呢绒外套        |  399.90 |  1200 |
    |       2 |  3 |           1 | 女装/女士精品       | 卫衣            |   89.90 |  1500 |
    |       3 |  4 |           1 | 女装/女士精品       | 牛仔裤          |   89.90 |  3500 |
    |       4 |  2 |           1 | 女装/女士精品       | 连衣裙          |   79.90 |  2500 |
    |       5 |  1 |           1 | 女装/女士精品       | T恤             |   39.90 |  1000 |
    |       6 |  5 |           1 | 女装/女士精品       | 百褶裙          |   29.90 |   500 |
    |       1 |  8 |           2 | 户外运动            | 山地自行车      | 1399.90 |  2500 |
    |       2 | 11 |           2 | 户外运动            | 运动外套        |  799.90 |   500 |
    |       3 | 12 |           2 | 户外运动            | 滑板            |  499.90 |  1200 |
    |       4 |  7 |           2 | 户外运动            | 自行车          |  399.90 |  1000 |
    |       5 | 10 |           2 | 户外运动            | 骑行装备        |  399.90 |  3500 |
    |       6 |  9 |           2 | 户外运动            | 登山杖          |   59.90 |  1500 |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    12 rows in set (0.00 sec)
    
    # 查询 goods 数据表中每个商品分类下价格最高的 3 种商品信息。
    SELECT * 
    FROM
    ( SELECT ROW_NUMBER() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num, id, category_id, category, NAME, price, stock FROM goods ) t 
    WHERE row_num <= 3;
    
    # 结果
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    | row_num | id | category_id | category            | NAME            | price   | stock |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    |       1 |  6 |           1 | 女装/女士精品       | 呢绒外套        |  399.90 |  1200 |
    |       2 |  3 |           1 | 女装/女士精品       | 卫衣            |   89.90 |  1500 |
    |       3 |  4 |           1 | 女装/女士精品       | 牛仔裤          |   89.90 |  3500 |
    |       1 |  8 |           2 | 户外运动            | 山地自行车      | 1399.90 |  2500 |
    |       2 | 11 |           2 | 户外运动            | 运动外套        |  799.90 |   500 |
    |       3 | 12 |           2 | 户外运动            | 滑板            |  499.90 |  1200 |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    6 rows in set (0.00 sec)
    ```

- 序号函数 - `RANK()` 函数

  对序号进行并列排序，并且会跳过重复的序号，比如序号为 1、1、3。

    ```sql
    # 获取goods 数据表中各类别的价格从高到低排序的各商品信息。
    SELECT
    	RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num,
    	id, category_id, category, NAME, price, stock 
    FROM
    	goods;
    # 结果：
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    | row_num | id | category_id | category            | NAME            | price   | stock |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    |       1 |  6 |           1 | 女装/女士精品       | 呢绒外套        |  399.90 |  1200 |
    |       2 |  3 |           1 | 女装/女士精品       | 卫衣            |   89.90 |  1500 |
    |       2 |  4 |           1 | 女装/女士精品       | 牛仔裤          |   89.90 |  3500 |
    |       4 |  2 |           1 | 女装/女士精品       | 连衣裙          |   79.90 |  2500 |
    |       5 |  1 |           1 | 女装/女士精品       | T恤             |   39.90 |  1000 |
    |       6 |  5 |           1 | 女装/女士精品       | 百褶裙          |   29.90 |   500 |
    |       1 |  8 |           2 | 户外运动            | 山地自行车      | 1399.90 |  2500 |
    |       2 | 11 |           2 | 户外运动            | 运动外套        |  799.90 |   500 |
    |       3 | 12 |           2 | 户外运动            | 滑板            |  499.90 |  1200 |
    |       4 |  7 |           2 | 户外运动            | 自行车          |  399.90 |  1000 |
    |       4 | 10 |           2 | 户外运动            | 骑行装备        |  399.90 |  3500 |
    |       6 |  9 |           2 | 户外运动            | 登山杖          |   59.90 |  1500 |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    12 rows in set (0.00 sec)
    ```

- 序号函数 - `DENSE_RANK()` 函数

  对序号进行并列排序，并且不会跳过重复的序号，比如序号为 1、1、2。

    ```sql
    # 获取 goods 数据表中各类别的价格从高到低排序的各商品信息。
    SELECT
    	DENSE_RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num,
    	id, category_id, category, NAME, price, stock 
    FROM
    	goods;
    	
    # 结果：
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    | row_num | id | category_id | category            | NAME            | price   | stock |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    |       1 |  6 |           1 | 女装/女士精品       | 呢绒外套        |  399.90 |  1200 |
    |       2 |  3 |           1 | 女装/女士精品       | 卫衣            |   89.90 |  1500 |
    |       2 |  4 |           1 | 女装/女士精品       | 牛仔裤          |   89.90 |  3500 |
    |       3 |  2 |           1 | 女装/女士精品       | 连衣裙          |   79.90 |  2500 |
    |       4 |  1 |           1 | 女装/女士精品       | T恤             |   39.90 |  1000 |
    |       5 |  5 |           1 | 女装/女士精品       | 百褶裙          |   29.90 |   500 |
    |       1 |  8 |           2 | 户外运动            | 山地自行车      | 1399.90 |  2500 |
    |       2 | 11 |           2 | 户外运动            | 运动外套        |  799.90 |   500 |
    |       3 | 12 |           2 | 户外运动            | 滑板            |  499.90 |  1200 |
    |       4 |  7 |           2 | 户外运动            | 自行车          |  399.90 |  1000 |
    |       4 | 10 |           2 | 户外运动            | 骑行装备        |  399.90 |  3500 |
    |       5 |  9 |           2 | 户外运动            | 登山杖          |   59.90 |  1500 |
    +---------+----+-------------+---------------------+-----------------+---------+-------+
    12 rows in set (0.01 sec)
    ```

- 分布函数 - `PERCENT_RANK()` 函数

  是等级值百分比函数。按照 `(rank - 1) / (rows - 1)` 进行计算。其中，rank 的值为使用 RANK() 函数产生的序号，rows 的值为当前窗口的总记录数。

    ```sql
    # 计算 goods 数据表中名称为“女士/女士精品”的类别下的商品的 PERCENT_RANK 值。
    
    # 写法一：
    SELECT
    	RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS r,
    	PERCENT_RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS pr,
    	id, category_id, category, NAME, price, stock 
    FROM
    	goods 
    WHERE
    	category_id = 1;
    
    # 写法二：
    SELECT
    	RANK() OVER w AS r,
    	PERCENT_RANK() OVER w AS pr,
    	id, category_id, category, NAME, price, stock 
    FROM
    	goods 
    WHERE
    	category_id = 1 WINDOW w AS ( PARTITION BY category_id ORDER BY price DESC );
    
    # 结果
    +---+-----+----+-------------+---------------------+--------------+--------+-------+
    | r | pr  | id | category_id | category            | NAME         | price  | stock |
    +---+-----+----+-------------+---------------------+--------------+--------+-------+
    | 1 |   0 |  6 |           1 | 女装/女士精品       | 呢绒外套     | 399.90 |  1200 |
    | 2 | 0.2 |  3 |           1 | 女装/女士精品       | 卫衣         |  89.90 |  1500 |
    | 2 | 0.2 |  4 |           1 | 女装/女士精品       | 牛仔裤       |  89.90 |  3500 |
    | 4 | 0.6 |  2 |           1 | 女装/女士精品       | 连衣裙       |  79.90 |  2500 |
    | 5 | 0.8 |  1 |           1 | 女装/女士精品       | T恤          |  39.90 |  1000 |
    | 6 |   1 |  5 |           1 | 女装/女士精品       | 百褶裙       |  29.90 |   500 |
    +---+-----+----+-------------+---------------------+--------------+--------+-------+
    6 rows in set (0.00 sec)
    ```

- 分布函数 - `CUME_DIST()` 函数

  查询小于或等于某个值的比例

    ```sql
    # 查询 goods 数据表中小于或等于当前价格的比例。
    SELECT
    	CUME_DIST() OVER ( PARTITION BY category_id ORDER BY price ASC ) AS cd,
    	id, category, NAME, price
    FROM
    	goods;
    
    #结果：
    +---------------------+----+---------------------+-----------------+---------+
    | cd                  | id | category            | NAME            | price   |
    +---------------------+----+---------------------+-----------------+---------+
    | 0.16666666666666666 |  5 | 女装/女士精品       | 百褶裙          |   29.90 |
    |  0.3333333333333333 |  1 | 女装/女士精品       | T恤             |   39.90 |
    |                 0.5 |  2 | 女装/女士精品       | 连衣裙          |   79.90 |
    |  0.8333333333333334 |  3 | 女装/女士精品       | 卫衣            |   89.90 |
    |  0.8333333333333334 |  4 | 女装/女士精品       | 牛仔裤          |   89.90 |
    |                   1 |  6 | 女装/女士精品       | 呢绒外套        |  399.90 |
    | 0.16666666666666666 |  9 | 户外运动            | 登山杖          |   59.90 |
    |                 0.5 |  7 | 户外运动            | 自行车          |  399.90 |
    |                 0.5 | 10 | 户外运动            | 骑行装备        |  399.90 |
    |  0.6666666666666666 | 12 | 户外运动            | 滑板            |  499.90 |
    |  0.8333333333333334 | 11 | 户外运动            | 运动外套        |  799.90 |
    |                   1 |  8 | 户外运动            | 山地自行车      | 1399.90 |
    +---------------------+----+---------------------+-----------------+---------+
    12 rows in set (0.01 sec)
    ```

- 前后函数 - `LAG(expr, n)` 函数

  返回当前行的前 n 行的 expr 的值。

    ```sql
    # 查询 goods 表中前一个商品价格与当前商品价格的差值。
    SELECT
    	id, category, NAME, price, pre_price, price - pre_price AS diff_price 
    FROM
    	(
    	SELECT
    		id, category, NAME, price, LAG( price, 1 ) OVER w AS pre_price 
    	FROM
    	goods WINDOW w AS ( PARTITION BY category_id ORDER BY price ) 
    	) t;
    
    # 结果：
    +----+---------------------+-----------------+---------+-----------+------------+
    | id | category            | NAME            | price   | pre_price | diff_price |
    +----+---------------------+-----------------+---------+-----------+------------+
    |  5 | 女装/女士精品       | 百褶裙          |   29.90 |      NULL |       NULL |
    |  1 | 女装/女士精品       | T恤             |   39.90 |     29.90 |      10.00 |
    |  2 | 女装/女士精品       | 连衣裙          |   79.90 |     39.90 |      40.00 |
    |  3 | 女装/女士精品       | 卫衣            |   89.90 |     79.90 |      10.00 |
    |  4 | 女装/女士精品       | 牛仔裤          |   89.90 |     89.90 |       0.00 |
    |  6 | 女装/女士精品       | 呢绒外套        |  399.90 |     89.90 |     310.00 |
    |  9 | 户外运动            | 登山杖          |   59.90 |      NULL |       NULL |
    |  7 | 户外运动            | 自行车          |  399.90 |     59.90 |     340.00 |
    | 10 | 户外运动            | 骑行装备        |  399.90 |    399.90 |       0.00 |
    | 12 | 户外运动            | 滑板            |  499.90 |    399.90 |     100.00 |
    | 11 | 户外运动            | 运动外套        |  799.90 |    499.90 |     300.00 |
    |  8 | 户外运动            | 山地自行车      | 1399.90 |    799.90 |     600.00 |
    +----+---------------------+-----------------+---------+-----------+------------+
    12 rows in set (0.00 sec)
    ```

- 前后函数 - `LEAD(expr, n)` 函数

  返回当前行的后 n 行的 expr 的值。

    ```sql
    # 查询 goods 数据表中后一个商品价格与当前商品价格的差值。
    SELECT
    	id, category, NAME, behind_price, price,behind_price - price AS diff_price 
    FROM
    	(
    	SELECT
    		id, category, NAME, price, LEAD( price, 1 ) OVER w AS behind_price 
    FROM
    	goods WINDOW w AS ( PARTITION BY category_id ORDER BY price )) t;
    
    # 结果:
    +----+---------------------+-----------------+--------------+---------+------------+
    | id | category            | NAME            | behind_price | price   | diff_price |
    +----+---------------------+-----------------+--------------+---------+------------+
    |  5 | 女装/女士精品       | 百褶裙          |        39.90 |   29.90 |      10.00 |
    |  1 | 女装/女士精品       | T恤             |        79.90 |   39.90 |      40.00 |
    |  2 | 女装/女士精品       | 连衣裙          |        89.90 |   79.90 |      10.00 |
    |  3 | 女装/女士精品       | 卫衣            |        89.90 |   89.90 |       0.00 |
    |  4 | 女装/女士精品       | 牛仔裤          |       399.90 |   89.90 |     310.00 |
    |  6 | 女装/女士精品       | 呢绒外套        |         NULL |  399.90 |       NULL |
    |  9 | 户外运动            | 登山杖          |       399.90 |   59.90 |     340.00 |
    |  7 | 户外运动            | 自行车          |       399.90 |  399.90 |       0.00 |
    | 10 | 户外运动            | 骑行装备        |       499.90 |  399.90 |     100.00 |
    | 12 | 户外运动            | 滑板            |       799.90 |  499.90 |     300.00 |
    | 11 | 户外运动            | 运动外套        |      1399.90 |  799.90 |     600.00 |
    |  8 | 户外运动            | 山地自行车      |         NULL | 1399.90 |       NULL |
    +----+---------------------+-----------------+--------------+---------+------------+
    12 rows in set (0.00 sec)
    ```

- 首尾函数 - `FIRST_VALUE(expr)` 函数 和 `LAST_VALUE（expr)` 函数

  `FIRST_VALUE(expr)` 函数返回第一个 expr 的值。`LAST_VALUE（expr)` 函数 返回最后一个 expr 的值。

  > 注意：
  >
  > 在 LAST_VALUE(expr) 函数中，默认帧规范为 `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`，这意味着框架从第一行开始，到当前行结束。为了获取所有数据中最后一条，需要将框架规格更改为 `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING `。

    ```sql
    # 按照价格排序，查询第一个商品的价格信息
    SELECT
    	id, category, NAME, price, stock, FIRST_VALUE( price ) OVER w AS first_price 
    FROM
    	goods WINDOW w AS ( PARTITION BY category_id ORDER BY price );
    
    # 结果：
    +----+---------------------+-----------------+---------+-------+-------------+
    | id | category            | NAME            | price   | stock | first_price |
    +----+---------------------+-----------------+---------+-------+-------------+
    |  5 | 女装/女士精品       | 百褶裙          |   29.90 |   500 |       29.90 |
    |  1 | 女装/女士精品       | T恤             |   39.90 |  1000 |       29.90 |
    |  2 | 女装/女士精品       | 连衣裙          |   79.90 |  2500 |       29.90 |
    |  3 | 女装/女士精品       | 卫衣            |   89.90 |  1500 |       29.90 |
    |  4 | 女装/女士精品       | 牛仔裤          |   89.90 |  3500 |       29.90 |
    |  6 | 女装/女士精品       | 呢绒外套        |  399.90 |  1200 |       29.90 |
    |  9 | 户外运动            | 登山杖          |   59.90 |  1500 |       59.90 |
    |  7 | 户外运动            | 自行车          |  399.90 |  1000 |       59.90 |
    | 10 | 户外运动            | 骑行装备        |  399.90 |  3500 |       59.90 |
    | 12 | 户外运动            | 滑板            |  499.90 |  1200 |       59.90 |
    | 11 | 户外运动            | 运动外套        |  799.90 |   500 |       59.90 |
    |  8 | 户外运动            | 山地自行车      | 1399.90 |  2500 |       59.90 |
    +----+---------------------+-----------------+---------+-------+-------------+
    12 rows in set (0.01 sec)
    
    # 按照价格排序，查询最后一个商品的价格信息
    SELECT
    	id, category, NAME, price, stock, LAST_VALUE( price ) OVER w AS last_price 
    FROM
    	goods WINDOW w AS ( PARTITION BY category_id ORDER BY price RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING );
    
    # 结果：
    +----+---------------------+-----------------+---------+-------+------------+
    | id | category            | NAME            | price   | stock | last_price |
    +----+---------------------+-----------------+---------+-------+------------+
    |  5 | 女装/女士精品       | 百褶裙          |   29.90 |   500 |     399.90 |
    |  1 | 女装/女士精品       | T恤             |   39.90 |  1000 |     399.90 |
    |  2 | 女装/女士精品       | 连衣裙          |   79.90 |  2500 |     399.90 |
    |  3 | 女装/女士精品       | 卫衣            |   89.90 |  1500 |     399.90 |
    |  4 | 女装/女士精品       | 牛仔裤          |   89.90 |  3500 |     399.90 |
    |  6 | 女装/女士精品       | 呢绒外套        |  399.90 |  1200 |     399.90 |
    |  9 | 户外运动            | 登山杖          |   59.90 |  1500 |    1399.90 |
    |  7 | 户外运动            | 自行车          |  399.90 |  1000 |    1399.90 |
    | 10 | 户外运动            | 骑行装备        |  399.90 |  3500 |    1399.90 |
    | 12 | 户外运动            | 滑板            |  499.90 |  1200 |    1399.90 |
    | 11 | 户外运动            | 运动外套        |  799.90 |   500 |    1399.90 |
    |  8 | 户外运动            | 山地自行车      | 1399.90 |  2500 |    1399.90 |
    +----+---------------------+-----------------+---------+-------+------------+
    12 rows in set (0.00 sec)
    ```

- 其它函数 - `NTH_VALUE(expr, n)` 函数

  返回第 n 个 expr 的值。

    ```sql
    # 查询 goods 数据表中排名第 3 和 第 4 的价格信息
    SELECT
    	id, category, NAME, price, NTH_VALUE( price, 2 ) OVER w AS second_price, NTH_VALUE(price, 3) OVER w AS third_price 
    FROM
    	goods WINDOW w AS ( PARTITION BY category_id ORDER BY price );
    	
    # 结果：
    +----+---------------------+-----------------+---------+--------------+-------------+
    | id | category            | NAME            | price   | second_price | third_price |
    +----+---------------------+-----------------+---------+--------------+-------------+
    |  5 | 女装/女士精品       | 百褶裙          |   29.90 |         NULL |        NULL |
    |  1 | 女装/女士精品       | T恤             |   39.90 |        39.90 |        NULL |
    |  2 | 女装/女士精品       | 连衣裙          |   79.90 |        39.90 |       79.90 |
    |  3 | 女装/女士精品       | 卫衣            |   89.90 |        39.90 |       79.90 |
    |  4 | 女装/女士精品       | 牛仔裤          |   89.90 |        39.90 |       79.90 |
    |  6 | 女装/女士精品       | 呢绒外套        |  399.90 |        39.90 |       79.90 |
    |  9 | 户外运动            | 登山杖          |   59.90 |         NULL |        NULL |
    |  7 | 户外运动            | 自行车          |  399.90 |       399.90 |      399.90 |
    | 10 | 户外运动            | 骑行装备        |  399.90 |       399.90 |      399.90 |
    | 12 | 户外运动            | 滑板            |  499.90 |       399.90 |      399.90 |
    | 11 | 户外运动            | 运动外套        |  799.90 |       399.90 |      399.90 |
    |  8 | 户外运动            | 山地自行车      | 1399.90 |       399.90 |      399.90 |
    +----+---------------------+-----------------+---------+--------------+-------------+
    12 rows in set (0.00 sec)
    ```

- 其它函数 - `NTILE(n)` 函数

  将分区中的有序数据分为 n 个桶，记录桶编号。

    ```sql
    # 将 goods 表中的商品按照价格分为 3 组。
    SELECT 
    	NTILE(3) OVER w AS nt, id, category, NAME, price
    FROM
    	goods WINDOW w AS ( PARTITION BY category_id ORDER BY price );
    	
    # 结果：
    +----+----+---------------------+-----------------+---------+
    | nt | id | category            | NAME            | price   |
    +----+----+---------------------+-----------------+---------+
    |  1 |  5 | 女装/女士精品       | 百褶裙          |   29.90 |
    |  1 |  1 | 女装/女士精品       | T恤             |   39.90 |
    |  2 |  2 | 女装/女士精品       | 连衣裙          |   79.90 |
    |  2 |  3 | 女装/女士精品       | 卫衣            |   89.90 |
    |  3 |  4 | 女装/女士精品       | 牛仔裤          |   89.90 |
    |  3 |  6 | 女装/女士精品       | 呢绒外套        |  399.90 |
    |  1 |  9 | 户外运动            | 登山杖          |   59.90 |
    |  1 |  7 | 户外运动            | 自行车          |  399.90 |
    |  2 | 10 | 户外运动            | 骑行装备        |  399.90 |
    |  2 | 12 | 户外运动            | 滑板            |  499.90 |
    |  3 | 11 | 户外运动            | 运动外套        |  799.90 |
    |  3 |  8 | 户外运动            | 山地自行车      | 1399.90 |
    +----+----+---------------------+-----------------+---------+
    12 rows in set (0.00 sec)
    ```

#### 2.4 小结

窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。

### 3. 新特性2: 公用表表达式

公用表表达式 (或通用表表达式) 简称 CTE (Common Table Expressions)。CTE 是一个命名的临时结果集，作用范围是当前语句。CTE 可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE 可以引用其它 CTE，但子查询不能引用其它子查询。所以，可以考虑代替子查询。

一句语法结构和执行方式的不同，公用表表达式分为**普通公用表表达式**和**递归公用表表达式**两种。

#### 3.1 普通公用表表达式

普通公用表表达式的语法结构是：

```sql
WITH CTE名称
AS (子查询)
SELECT|DELETE|UPDATE 语句;
```

普通公用表表达式类似于子查询，不过跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。

#### 3.2 递归公用表表达式

递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是可以调用自己。它的语法结构是：

```sql
WITH RECURSIVE
CTE名称 AS (子查询)
SELECT|DELETE|UPDATE 语句;
```

递归公用表表达式由两部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL] 进行连接。这里的**种子查询，意思就是获得递归的初始值**。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。

#### 3.3 小结

公用表表达式可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根结点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。
