---
title: 约束
createTime: 2024/12/19 14:04:30
permalink: /database/d32c6ose/
---

### 1. 约束 (constraint) 概述

#### 1.1 为什么需要约束

数据完整性 (Data Integrity) 是指数据的精确性 (Accuracy) 和可靠性 (Reliability)。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。

为了保证数据的完整性，SQL 规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：

- 实体完整性 (Entity Integrity)：例如，同一个表中，不能存在两条完全相同无法区分的记录。
- 域完整性 (Domain Integrity)：例如：年龄范围 0～120，性别范围"男/女"。
- 引用完整性 (Referential Integrity)：例如：员工所在部门，在部门表中要能找到这个部门
- 用户自定义完整性 (User-defined Integrity)：例如：用户名唯一、密码不能为空，本部门经理的工资不能高于本部门职工的平均工资的 5 倍。

#### 1.2 什么是约束

约束是表级的强制规定。可以在创建表时规定约束 (通过 CREATE TABLE 语句)，或者在表创建之后通过 ALTER TABLE 语句规定约束。

#### 1.3 约束的分类

- 根据约束数据列的限制，约束可分为：
    - 单列约束：每个约束只约束一列
    - 多列约束：每个约束可约束多列数据
- 根据约束的作用范围，约束可分为：
    - 列级约束：只能作用在一个列上，跟在列的定义后面
    - 表级约束：可以作用在多个列上，不与列一起，而是单独定义

|          | 位置         | 支持的约束类型             | 是否可以起约束名    |
| -------- | ------------ | -------------------------- | ------------------- |
| 列级约束 | 列的后面     | 语法都支持，但外键没有效果 | 不可以              |
| 表级约束 | 所有列的下面 | 默认和非空不支持，其他支持 | 可以 (主键没有效果) |

- 根据约束起的作用，约束可分为：
    - NOT NULL 非空约束，规定某个字段不能为空
    - UNIQUE 唯一约束，规定某个字段在整个表中是唯一的
    - PRIMARY KEY 主键 (非空且唯一) 约束
    - FOREIGN KEY 外键约束
    - CHECK 检查约束
    - DEFAULT 默认值约束

> 注意：MySQL 不支持 check 约束，但是可以使用 check 约束，而没有任何效果

- 查看某个表已有的约束

    ```sql
    # information_schema 数据库名 (系统库)
    # table_constraints 标名称 (专门存储各个表的约束)
    SELECT * FROM information_schema.table_constraints
    WHERE table_name = '标名称';
    ```

### 2.非空约束

#### 2.1 作用

限定某个字段/某列的值不允许为空

#### 2.2 关键字

NOT NULL

#### 2.3 特点

- 默认，所有的类型的值都可以是 NULL，包括 INT、FLOAT 等数据类型
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空
- 一个表可以有很多列都分别限定了非空
- 空字符串"不等于 NULL"，0 也不等于 NULL

#### 2.4 添加非空约束

- 建表时

    ```sql
    CREATE TABLE  表名称(
    	column1 数据类型,
      column2 数据类型 NOT NULL,
      column3 数据类型 NOT NULL
    );
    ```

- 建表后

    ```sql
    ALTER TABLE 表名称
    MODIFY column 数据类型 NOT NULL;
    ```

#### 2.5 删除非空约束

```sql
ALTER TABLE 表名称 MODIFY column 数据类型 NULL;
或
ALTER TABLE 表名称 MODIFY column 数据类型;
```

### 3. 唯一性约束

#### 3.1 作用

用来限制某个字段/某列的值不能重复。

#### 3.2 关键字

UNIQUE

#### 3.3 特点

- 同一个表可以有多个唯一约束。
- 唯一约束可以是某一列的值唯一，也可以多个列组合的值唯一。
- 唯一性约束允许列值为空。
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。
- MySQL 会给唯一约束的列上默认创建一个唯一索引。

#### 3.4 添加唯一约束

- 建表时

    ```sql
    # 列级约束
    CREATE TABLE 表名称(
    	column1 数据类型,
      column2 数据类型 UNIQUE,
      column3 数据类型 UNIQUE KEY,
    );
    # 表级约束
    CREATE TABLE 表名称(
    	column1 数据类型,
      column2 数据类型 UNIQUE,
    	CONSTRAINT 约束名 UNIQUE 字段名
    );
    ```

- 建表后

    ```sql
    # 字段列表中如果是一个字段，表示该列的值唯一，如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的
    ALTER TABLE 表名称 ADD UNIQUE KEY(字段列表);
    ALTER TABLE 表名称 MODIFY 字段名 数据类型 UNIQUE;
    ```

#### 3.5 关于复合唯一约束

```sql
CREATE TABLE 表名称(
	column1 数据类型,
  column2 数据类型,
  column3 数据类型,
  UNIQUE KEY(字段列表)# 字段列表中写的是多个字段名，用逗号分隔，表示多个字段的组合是唯一的。
);
```

#### 3.6 删除唯一约束

- 添加唯一性约束的列上也会自动创建唯一索引。
- 删除唯一约束只能通过删除唯一索引的方式删除。
- 删除时需要制定唯一索引名，唯一索引名就和唯一约束名一样。
- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和 () 中排在第一个的列名相同。也可以自定义唯一性约束名。

```sql
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; # 查看都有哪些约束
ALTER TABLE 表名
DROP INDEX 唯一索引名;
```

> 注意：可以通过 `show index from 表名称;` 查看表的索引

### 4. 主键约束

#### 4.1 作用

用来唯一标识表中的一行记录。

#### 4.2 关键字

PRIMARY KEY

#### 4.3 特点

- 主键约束相当于唯一约束 + 非空约束的组合，主键约束列不允许重复，也不允许出现空值。
- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。
- 主键约束对应着表中的一列或者多列 (复合主键)。
- 如果是多列组合的符合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。
- MySQL 的主键名总是 PRIMARY，就算自己命名了主键约束名也没用。
- 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引 (能够根据主键查询的，就根据主键查询，效率跟高)。如果删除主键约束了，主键约束对应的索引就自动删除了。
- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。

#### 4.4 添加主键约束

- 建表时：

```sql
# 列级约束
CREATE TABLE 表名称(
	column1 数据类型 PRIMARY KEY,
  column2 数据类型 UNIQUE,
  column3 数据类型 UNIQUE KEY,
);
# 表级约束 复合主键
CREATE TABLE 表名称(
	column1 数据类型,
  column2 数据类型 UNIQUE,
  column3 数据类型 UNIQUE KEY,
  CONSTRAINT 约束名 PRIMARY KEY(column1, column2)
);
```

- 建表后：

```sql
ALTER TABLE 表名
ADD PRIMARY KEY (字段名);
```

#### 4.5 删除主键约束

```sql
ALTER TABLE 表名
DROP PRIMARY KEY;
```

### 5. 自增列

#### 5.1 作用

某个字段的值自增

#### 5.2 关键字

AUTO_INCREMENT

#### 5.3 特点和要求

- 一个表最多只能有一个自增长列
- 当需要产生唯一标识符或顺序值时，可设置自增长
- 自增长列约束的列必须是键列 (主键列，唯一键列)
- 自增约束的列的数据类型必须是整数类型
- 如果自增列指定了 0 和 NULL，会在当前最大值的基础上自增；如果自增列手动置顶了具体值，直接赋值为具体值。

#### 5.4 指定自增约束

- 建表时：

```sql
CREATE TABLE 标名称(
	column1 数据类型 PRIMARY KEY ATUO_INCREMENT,
);
CREATE TABLE 标名称(
	column1 数据类型 UNIQUE KEY ATUO_INCREMENT,
);
```

- 建表后：

```sql
ALTER TABLE 表名 
MODIFY column 数据类型 ATUO_INCREMENT;
```

#### 5.5 删除自增约束

```sql
ALTER TABLE 表名 
MODIFY column 数据类型; # 去掉 ATUO_INCREMENT
```

#### 5.6 MySQL 8.0 新特性——自增变量的持久化

在 MySQL 8.0 之前，自增主键 ATUO_INCREMENT 的值如果大于 max(primary key) + 1，在 MySQL 重启后，会重置 ATUO_INCREMENT = max(primary key) + 1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。在 MySQL 5.7 系统中，对于自增主键的分配规则，是由 InnoDB 数据字典内部一个计数器来决定的，而该计数器只在内存中维护，并不会持久化道磁盘中。当数据库重启时，该计数器会被初始化。在 MySQL 8.0 系统中将自增主键的计数器持久化道重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB 会根据重做日志中的信息来初始化计数器的内存值。

### 6. 外键约束

#### 6.1 作用

限定某个表的某个字段的引用完整性。

比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。

#### 6.2 关键字

FOREIGN KEY

#### 6.3 主表和从表/父表和子表

主表 (父表)：被引用的表，被参考的表。

从表 (子表)：引用别人的表，参考别人的表。

#### 6.4 特点

- 从表的外键列，必须引用/参考主表的键 (主键或唯一约束的列)

  为什么？因为被依赖/被参考的值必须是唯一的。

- 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名，也可以指定外键约束名。

- 创建 (CRETE) 表时就指定外键约束的话，先创建主表，再创建从表。

- 删表时，先删从表 (或先删外键约束)，在删除主表。

- 当主表的记录被从表参照时，主要的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。

- 在 “从表”中指定外键约束，并且一个表可以建立多个外键约束。

- 从表的外键列与主表被参照的列名可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现“ERROR 1005 (HY000): Can't crete table'database.tablename'(errno:150”。

- 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是列名，不是外键的约束名。(根据外键查询效率很高)

- 删除外键约束后，必须手动删除对应的索引。

#### 6.5 添加外键约束

- 建表时

    ```sql
    CREATE TABLE 主表名称(
    	column1 数据类型 PRIMARY KEY,
      column2 数据类型
    );
    
    CREATE TABLE 从表名称(
    	column1 数据类型 PRIMARY KEY,
      column2 数据类型 ，
      CONSTRAINT 外键约束名称 FOREIGN KEY (从表字段) REFERENCES 主表名(主表字段)
    );
    # 从表的某个字段的数据类型必须与主表字段的数据类型一致，逻辑意义也一样
    # 从表的某个字段的字段名可以与主表字段名一样，也可以不一样
    -- FOREIGN KEY：在表级别指定子表中的列
    -- REFERENCES：表示在父表中的列
    ```

- 建表后

    ```sql
    ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表字段) REFERENCES 主表名(主表字段) [ON UPDATE xx][ON DELETE xx];
    ```

总结：约束关系是针对双方的

- 添加了外键约束后，主表的修改和删除数据受约束
- 添加了外键约束后，从表的添加和修改数据受约束
- 在从表上建立外键，要求主表必须存在
- 删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除

#### 6.6 约束等级

- Cascade 方式：在父表上 update/delete 记录时，同步 update/delete 掉子表的匹配记录
- Set null 方式：在父表上 update/delete 记录时，将子表上匹配记录的列设为 null，但是要注意子表的外键列不能为 not null
- No action 方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行 update/delete 操作
- Restrict 方式：同 no action，都是立即检查外键约束
- Set default 方式：父表有变更时，子表将外键列设制成一个默认的值，但 InnoDb 不能识别。

如果没有置顶等级，就相当于 Restrict 方式。

**对于外键约束，最好是采用：`ON UPDATE CASCADE ON DELETE RESTRICT` 的方式**。

#### 6.7 删除外键约束

```sql
# 第一步先查看约束名和删除外键约束
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称'; #查看某个表的约束名

ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;

#第二步查看索引名和删除索引。注意只能手动删除
SHOW INDEX FROM 表名称;

ALTER TABLE 从表名 DROP INDEX 索引名;
```

#### 6.8 开发场景

**问题一：如果两个表之间有关系 (一对一、一对多)，它们之间是否一定要建外键约束**？

答：不是的

**问题二：建和不建外键约束有什么区别**？

答：建外键约束，你的操作 (创建表、删除表、添加、修改、删除) 会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，他的部门的值在部门表中找不到。

不建外键约束，你的操作 (创建表、删除表、添加、修改、删除) 不受限制，要保证数据的引用完整性，只能依靠程序员的自觉，或者是在 Java 程序中进行限定。例如：在员工表中，可以添加一个员工信息，它的部门指定为一个完全不存在的部门。

**问题三：那么建和不建外键约束和查询有没有关系**？

答：没有

> 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以，MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。

#### 6.9 阿里开发规范

【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

说明：(概念解释) 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时出发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。

### 7. CHECK 约束

#### 7.1 作用

检查某个字段的值是否符合 xx 要求，一般指的是值的范围。

#### 7.2 关键字

CHECK

#### 7.3 说明：MySQL 5.7 不支持

MySQL 5.7 可以使用 check 约束，但 check 约束对数据验证没有任何作用。添加数据时，没有任何错误或警告。但是 MySQL 8.0 中可以使用 check 约束了。

```sql
CREATE TABLE 表名(
	id INT AUTO_INCREMENT,
  name VARCHAR(20),
  age INT CHECK(age > 20),
  PRIMARY KEY(id)
);
```

### 8. DEFAULT 约束

#### 8.1 作用

给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显示赋值，则赋值为默认值。

#### 8.2 关键字

DEFAULT

#### 8.3 如果给字段加默认值

- 建表时：

```sql
CREATE TABLE 表名称(
	column1 数据类型 PRIMARY KEY,
  column1 数据类型 UNIQUE KEY NOT NULL,
  column1 数据类型 UNIQUE KEY,
  column1 数据类型 NOT NULL DEFAULT 默认值
);
```

- 建表后：

```sql
ALTER TABLE 表名称 MODIFY column 数据类型 DEFAULT 默认值;
# 如果这个字段原来有非空约束，你还保留非空约束，那么在加载默认值约束是，海的保留非空约束，否则非空约束就被删除了。
# 同理，再给某个字段加非空约束也一样，如果这个字段原来有默认值的约束，你想保留，也要在 modify 语句中保留默认值约束，否则就删除了
ALTER TABLE 表名称 MODIFY 字段名 数据类型 DEFAULT 默认值 NOT NULL;
```

#### 8.4 删除默认值约束

```sql
ALTER TABLE 表名称 MODIFY column 数据类型;
ALTER TABLE 表名称 MODIFY column 数据类型 NOT NULL;
```

### 9. 面试题

- 为什么建表时，加 NOT NULL DEFAULT 或 DEFAULT 0 ？

  答：不想让表中出现 NULL 值。

- 为什么不想要 NULL 值？

  答：1. 不好比较。NULL 是一种特殊值，比较时只能用专门的 IS NULL 和 IS NOT NULL 来比较。碰到运算符，通常返回 NULL。

  ​		2. 效率不高。影响提高索引效果。因此，我们往往在建表时 NOT NULL DEFAULT 或 DEFAULT 0。

- 带 AUTO_INCREMENT 约束的字段值是从 1 开始的吗？

  在 MySQL 中，默认 AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1.设置自增属性的时候，还可以指定第一条插入记录的自增字段的值，这样插入的记录的自增字段值从初识值开始递增，如在表中插入第一条记录，同时指定 id 值为 5，则以后插入的记录的 id 就会从 6 开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。

- 并不是每个表都可以任意选择存储引擎？

  外键约束不能跨引擎使用。

  MySQL 支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。