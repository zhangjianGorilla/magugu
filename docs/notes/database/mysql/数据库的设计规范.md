---
title: 数据库的设计规范
createTime: 2024/12/19 14:22:28
permalink: /database/b1lbiojt/
---

### 1. 为什么需要数据库设计

我们在设计数据表的时候，要考虑很多问题。比如：

- 用户都需要什么数据？需要在数据表中保存哪些数据？
- 如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？
- 如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？
- 如何让负责数据维护的人员更方便地使用数据库？
- 使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别。

现实情况中，面临的场景：

当数据库运行了一段时间之后，我们才发现数据表设计得有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站的正常访问。

如果是糟糕的数据库设计可能会造成以下问题：

- 数据冗余、信息重复，存储空间浪费
- 数据更新、插入、删除的一场
- 无法正确表示信息
- 丢失有效信息
- 程序性能差

良好的数据库设计则有以下优点：

- 节省数据的存储空间
- 能够保证数据的完整性
- 方便进行数据库应用系统的开发

总之，开始设置数据库的时候，我们就需要重视数据表的设计。为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。

### 2. 范式

#### 2.1 范式简介

**在关系型数据库中，关于数据表设计的基本原则、规则就称为范式**。可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

范式的英文名称是 Mormal Form，简称 NF。它是英国人 E.F.Codd 在上个世纪 70 年代提出关系数据库模型后总结出来的。范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。

#### 2.2 范式都包括哪些

目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式 (1NF)、第二范式 (2NF)、第三范式 (3NF)、巴斯-科德范式 (BCNF)、第四范式 (4NF) 和第五范式 (5NF，又称完美范式)。

数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式 (1NF)。在第一范式的基础上进一步满足更多规范要求的成为第二范式 (2NF)，其余范式以此类推。一般来说，在关系型数据库设计中，最高也就遵循到 BCNF，普遍还是 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。

![范式](/mysql/范式.png)

#### 2.3 键和相关属性的概念

范式的定义会使用到主键和候选键，数据库中的键  (Key) 由一个或者多个属性组成。数据表中常用的几种键和属性的定义：

- 超键：能唯一标识元组的属性集叫做超键。
- 候选键：如果超键不包括多余的属性，那么这个超键就是候选键。
- 主键：用户可以从候选键中选择一个作为主键。
- 外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。
- 主属性：包含在任一候选键中的属性称为主属性。
- 非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。

通常，我们也将候选键称之为码，把主键也称为主码。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。

举例：

这里有两个表：

球员表 (player)：球员编号｜ 姓名｜身份证号｜年龄｜球队编号

球队表 (team)：球队编号｜主教练｜球队所在地

- 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如 (球员编号) (球员编号，姓名) (身份证号，年龄) 等。
- 候选键：就是最小的超键，对于球员表来说，候选键就是 (球员编号) 或者身份证号。
- 主键：我们自己选定，也就是从候选键中选择一个，比如 (球员编号)。
- 外键：球员表中的球队编号。
- 主属性、非主属性：在球员表中，主属性是 (球员编号) (身份证号)，其他的属性 (姓名) (年龄) (球队编号) 都是非主属性。

#### 2.4 第一范式 (1st NF)

第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值不可再次拆分的最小数据单元。

我们在设计某个字段的时候，对于字段 X 来说，不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。

#### 2.5 第二范式 (2nd NF)

第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分**。如果指导主键的所有属性的值，就可以检索到任何元组 (行) 的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。

> 小结：第二范式 (2NF) 要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。
>
> 1 NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。

#### 2.6 第三范式 (3rd NF)

第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段和主键字段直接相关，也就是说，**要求数据表中的所有非主键字段不能依赖于其他非主键字段**。(即，不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于主键 C 的情况，即存在 A→B→C 的决定关系) 通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。

这里的主键可以拓展为候选键。

> 符合 3NF 后的数据模型通俗地讲，2NF 和 3NF 通常以这句话概括：“每个非主键属性依赖于主键，依赖于整个主键，并且除了主键别无他物”。

#### 2.7 小结

关于数据表的设计，有三个范式要遵循。

- 第一范式，确保每列保持原子性。数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。
- 第二范式，确保每列都和主键完全依赖。尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。
- 第三范式，确保每列都和主键列直接相关，而不是间接相关。

范式的优点：数据的标准化有助于消除数据库中的数据冗余，第三范式通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。

范式的缺点：范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。

范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join 表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。

> 范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。

### 3. 反范式化

#### 3.1 概述

有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量尽量减少冗余。

如果数据库中的数据量比较大，系统的 UV 和 PV 访问频次比较高，则完全按照 MySQL 的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。

**规范化 vs 性能**

> - 为满足某种商业目标，数据库性能比规范化数据库更重要
> - 在数据规范化的同时，要综合考虑数据库的性能
> - 通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间
> - 通过在给定的表中插入计算列，以方便查询

#### 3.2 应用举例

例如客户表和评论表，如果要查询该条评论的评论人名称，就需要关联客户表去查询客户的名称。如果经常性的去查询评论人，我们就可以在评论表中，添加评论人名称字段，就不用每次进行关联查询了。

#### 3.3 反范式的新问题

反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题：

- 存储空间变大了
- 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致
- 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源
- 在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂

#### 3.4 反范式的适用场景

当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式化的优化。

- 增加冗余字段的建议‘

  增加冗余字段一定要符合如下两个条件。只有满足这两个条件，才可以考虑增加冗余字段。

    - 这个冗余字段不需要经常进行修改
    - 这个冗余字段查询的时候不可或缺

- 历史快照、历史数据的需要

  在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。

  反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。

  简单总结下数据仓库和数据库在使用上的区别：

    - 数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据
    - 数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据
    - 数据库设计需要尽量避免冗余，单位了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。

### 4. BCNF (巴斯范式)

人们在 3NF 的基础上进行了改进，提出了巴斯范式 (BCNF)，也叫做巴斯-科德范式 (Boyce-Codd Normal Form)。BCNF 被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式，或扩充的第三范式，BCNF 不被称为第四范式。

若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到 BC 范式。一般来说，一个数据库设计符合 3NF 或 BCNF 就可以了。

### 5. 第四范式

多值依赖的概念：

- 多值依赖即属性之间的一对多关系，记为 K→→A。
- 函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。
- 平凡的多值依赖：全集 U = K + A，一个 K 可以对应于多个 A，即 K→→A。此时整个表就是一组一对多关系。
- 非平凡的多值依赖：全集 U = K + A + B，一个 K 可以对应于多个 A，也可以对应于多个 B，A 与 B 互相独立，即 K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。

第四范式即在满足巴斯-科德范式 (BCNF) 的基础上，消除非平凡且非函数依赖的多值依赖 (即把同一表内的多对多关系删除)。

### 6. 第五范式

除了第四范式外，还有更高级的第五范式 (又称完美范式) 和域键范式 (DKNF)。

在满足第四范式 (4NF) 的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式 R 中的每一个连接依赖均由 R 的候选键所隐含，则称此关系模式符合第五范式。

函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。

第五范式处理的是无损连接问题，这个范式基本没有任何实际意义，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个终极范式，该范式考虑所有的依赖和约束类型，但是实际价值也是最小的，只存在理论研究中。

### 7. ER 模型

数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。

其实，ER 模型就是一个这样的工具。ER 模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。**在开发基于数据库的信息系统的设计阶段，通常使用 ER 模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库**。

#### 7.1 ER 模型包括哪些要素？

**ER 模型中有三个要素，分别是实体、属性和关系**。

**实体**，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。

**属性**，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形来表示。

**关系**，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用菱形来表示。

注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，**可以独立存在的是实体，不可再分的是属性**。也就是说，属性不能包含其他属性。

#### 7.2 关系的类型

在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是一对一、一对多、多对多。

一对一：指实体之间的关系一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。

一对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。

多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。

#### 7.3 建模分析

ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键了。开发应用项目的实质，其实就是建模。

我们设计的案例是电商业务，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU (StockKeepingUnit，库存量单位) 和 SPU (Standard Product Unit，标准化产品单元) 的含义上，我们直接使用了 SKU，并没有提及 SPU 的概念。本次电商业务涉及总共有 8 个实体：

- 地址实体
- 用户实体
- 购物车实体
- 评论实体
- 商品实体
- 商品分类实体
- 订单实体
- 订单详情实体

其中，用户和商品分类是强实体，因为他们不需要依赖其他任何实体。而其他属于弱实体，因为他们虽然都可以独立存在，但是他们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以给电商业务创建 ER 模型了，如图：

![电商业务ER模型-1](/mysql/电商业务ER模型-1.png)

在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情是一对一的关系，商品和订单是多对多的关系。这个 ER 模型，包括了 8 个实体之间的 8 种关系。

- 用户可以在电商平台添加多个地址；
- 用户只能拥有一个购物车；
- 用户可以生成多个订单；
- 用户可以发表多条评论；
- 一件商品可以有多条评论；
- 每一个商品分类包含多种商品；
- 一个订单可以包含多个商品，一个商品可以在多个订单里。
- 订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品。

#### 7.4 ER 模型的细化

有了这个 ER 模型，我们就可以从整体上理解电商的业务了。刚刚的 ER 模型展示了电商业务的框架，但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之间的关系，还不能对应到具体的表，以及表于表之间的关联。我们需要把属性加上，用椭圆来表示，这样我们得到的 ER 模型就更加完整了。

因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的业务流程，然后把它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。

接下来分析一下各个实体都有哪些属性，如下所示。

- **地址实体**包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。
- **用户实体**包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。
- **购物车实体**包括购物车编号、用户编号、商品编号、商品数量、图片文件 URL。
- **订单实体**包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单时间。
- **订单详情实体**包括订单详情编号、订单编号、商品名称、商品编号、商品数量。
- **商品实体**包括商品编号、价格、商品名称、分类编号、是否销售、规格、颜色。
- **评论实体**包括评论 ID、评论内容、评论时间、用户编号、商品编号。
- **商品分类实体**包括类别编号、类别名称、父类别编号。

这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：

![电商业务ER模型-2](/mysql/电商业务ER模型-2.png)

#### 7.5 ER 模型图转换成数据表

通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：

- 一个实体通常转换成一个数据表；
- 一个多对多的关系，通常也转换成一个数据表；
- 一个一对一或者一对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；
- 属性转换成表的字段。

下面结合前面的 ER 模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从而把抽象出来的数据模型，落实到具体的数据库设计当中。

**一个实体转换成一个数据表**

**首先是强实体转换成数据表**：用户实体转换成用户表 (user_info) 的代码如下所示。

```sql
CREATE TABLE `user_info` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `user_name` varchar(200) DEFAULT NULL COMMENT '用户名称',
  `nick_name` varchar(200) DEFAULT NULL COMMENT '用户昵称',
  `password` varchar(200) DEFAULT NULL COMMENT '用户密码',
  `phone_num` varchar(200) DEFAULT NULL COMMENT '手机号',
  `email` varchar(200) DEFAULT NULL COMMENT '邮箱',
  `head_imd` varchar(200) DEFAULT NULL COMMENT '头像',
  `user_level` varchar(200) DEFAULT NULL COMMENT '用户级别',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='用户表';
```

商品分类实体转换成商品分类表 (base_category)，由于商品分类可以有一级分类和二级分类，比如一级分类有家居、手机等等分类，二级分类可以根据手机的一级分类分为手机配件，运营商等，这里我们把商品分类实体规划为两张表，分别是一级分类表和二级分类表，之所以这么规划是因为一级分类和二级分类都是有限的，存储为两张表业务结构更加清晰。

```sql
# 一级分类表
CREATE TABLE `base_category1` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号'，
  `name` varchar(10) NOT NULL COMMENT '分类名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='一级分类表';

# 二级分类表
CREATE TABLE `base_category2` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(200) NOT NULL COMMENT '二级分类名称',
  `category1_id` bigint(20) DEFAULT NULL COMMENT '一级分类编号',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='二级分类表';
```

那么如果规划一张表，表结构如下所示。

```sql
CREATE TABLE `base_category` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(200) NOT NULL COMMENT '二级分类名称',
  `category1_parent_id` bigint(20) DEFAULT NULL COMMENT '父分类编号',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='分类表';
```

如果这样分类的话，那么查询一级分类的时候，就需要判断父分类编号是否为空，但是如果插入二级分类的时候也是空，就容易造成业务数据混乱。而且查询二级分类的时候 `IS NOT NULL` 条件是无法使用到索引的。同时，这样的设计也不符合第二范式 (因为父分类编号并不依赖分类编号 ID，因为父分类编号可以有很多数据为 NULL)，所以就需要进行表的拆分。因此无论是业务需求还是数据库表的规范来看都应该拆分为两张表。

**再把弱实体转换成数据表**：

地址实体转换成地址表 (user_address)，如下所示。

```sql
CREATE TABLE `user_address` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `province` varchar(500) DEFAULT NULL COMMENT '省',
  `city` varchar(500) DEFAULT NULL COMMENT '市',
  `user_address` varchar(500) DEFAULT NULL COMMENT '具体地址',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `consignee` varchar(40) DEFAULT NULL COMMENT '收件人',
  `phone_num` varchar(40) DEFAULT NULL COMMENT '联系方式',
  `is_fefault` varchar(1) DEFAULT NULL COMMENT '是否是默认',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='用户地址表；'
```

订单实体转换成订单表 (order_info)，如下所示，实际业务中订单的信息会非常多，这里做了简化。

```sql
CREATE TABLE `order_info` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `consignee` varchar(100) DEFAULT NULL COMMENT '收货人',
  `consignee_tel` varchar(20) DEFAULT NULL COMMENT '收件人电话',
  `total_amount` decimal(10,2) DEFAULT NULL COMMENT '总金额',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `payment_way` varchar(20) DEFAULT NULL COMMENT '付款方式',
  `delivery_address` varchar(1000) DEFAULT NULL COMMENT '送货地址',
  `create_time` datetime DEFAULT NULL COMMENT '下单时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='订单表';
```

订单详情实体转换成订单详情表 (order_detail)，如下所示。

```sql
# 订单详情表
CREATE TABLE `order_detail` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单详情编号',
  `order_id` bigint(20) DEFAULT NULL COMMENT '订单编号',
  `sku_id` bigint(20) DEFAULT NULL COMMENT 'sku_id',
  `sku_name` varchar(200) DEFAULT NULL COMMENT 'sku 名称',
  `sku_num` varchar(200) DEFAULT NULL COMMENT '购买个数',
  `create_time` datetime DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='订单明细表';
```

购物车实体转换成购物车表 (cart_info)，如下所示。

```sql
CREATE TABLE `cart_info` (
	`cart_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `user_id` varchar(200) DEFAULT NULL COMMENT '用户id',
  `sku_id` bigint(20) DEFAULT NULL COMMENT 'sku_id',
  `sku_num` int(11) DEFAULT NULL COMMENT '数量',
  `img_url` varchar(500) DEFAULT NULL COMMENT '图片文件',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='购物车表';
```

评论实体转换成评论表

```sql
CREATE TABLE `sku_comments` (
	`comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论编号',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户编号',
  `sku_id` bigint(20) DEFAULT NULL COMMENT 'sku_id',
  `comment` varchar(2000) DEFAULT NULL COMMENT '评论内容',
  `create_time` datetime DEFAULT NULL COMMENT '评论时间',
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='商品评论表';
```

商品实体转换成商品表 (members)，如下所示。

```sql
CREATE TABLE `sku_info` (
	`sku_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品编号itemID',
  `price` decimal(10,0) DEFAULT NULL COMMENT '价格',
  `sku_name` varchar(200) DEFAULT NULL COMMENT 'sku 名称',
  `sku_desc` varchar(2000) DEFAULT NULL COMMENT '商品规格描述',
  `category3_id` bigint(20) DEFAULT NULL COMMENT '三级分类id(冗余)',
  `color` varchar(2000) DEFAULT NULL COMMENT '颜色',
  `is_sale` tinyint(3) NOT NULL DEFAULT '0' COMMENT '是否销售(1:是 0:否)',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='商品表';
```

**一个多对多的关系转换成一个数据表**

这个 ER 模型中的多对多的关系有 一个，即商品和订单之间的关系，同品类的商品可以出现在不同的订单中，不同的订单也可以包含同一类型的商品，所以它们之间的关系是多对多。针对这种情况需要设计一个独立的表来表示，这种表一般称为中间表。

我们可以设计一个独立的订单详情表，来代替商品和订单之间的包含关系。这个表关联到两个实体，分别是订单、商品。所以，表中必须要包括这两个实体转换成的表的主键。除此之外，我们还要包括该关系自有的属性：商品数量，商品下单价格以及商品名称。

```sql
# 订单详情表
CREATE TABLE `order_detail` (
	`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单详情编号',
  `order_id` bigint(20) DEFAULT NULL COMMENT '订单编号',
  `sku_id` bigint(20) DEFAULT NULL COMMENT 'sku_id',
  `sku_name` varchar(200) DEFAULT NULL COMMENT 'sku名称',
  `sku_num` varchar(200) DEFAULT NULL COMMENT '购买个数',
  `create_time` datetime DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='订单明细表';
```

**通过外键来表达一对多的关系**

在上面的表的设计中，我们可以用外键来表达一对多的关系。比如在商品评论表 sku_comments 中，分别把 user_id、sku_id 定义成外键，以使用下面的语句设置外键。

```sql
CONSTRAINT fk_comment_user FOREIGN KEY (user_id) REFERENCES user_info (id),
CONSTRAINT fk_comment_sku FOREIGN KEY (sku_id) REFERENCES sku_info (sku_id)
```

外键约束主要是在数据库层面上保证数据的一致性，但是因为插入和更新数据需要检查外键，理论上性能会有所下降，对性能是负面的影响。

实际的项目，不建议使用外键，一方面是降低开发的复杂度 (有外键的话主从表类的操作必须是先操作主表)，另外是有外键在处理数据的时候非常麻烦。在电商平台，由于并发业务量比较大，所以一般不设置外键，以免影响数据库性能。

在应用层面做数据的一致性检查，本来就是一个正常的功能需求。如学生选课的场景，课程肯定不是输入的，而是通过下来或者查找等方式从系统中进行选取，就能保证是合法的课程 ID，因此就不需要靠数据库的外键来检查了。

**把属性转换成表的字段**

在刚刚的设计中，我们也完成了把属性都转换成了表的字段，比如把商品属性转换成了商品信息表中的字段。

```sql
CREATE TABLE `sku_info` (
	`sku_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品编号itemID',
  `price` decimal(10,0) DEFAULT NULL COMMENT '价格',
  `sku_name` varchar(200) DEFAULT NULL COMMENT 'sku 名称',
  `sku_desc` varchar(2000) DEFAULT NULL COMMENT '商品规格描述',
  `category3_id` bigint(20) DEFAULT NULL COMMENT '三级分类id(冗余)',
  `color` varchar(2000) DEFAULT NULL COMMENT '颜色',
  `is_sale` tinyint(3) NOT NULL DEFAULT '0' COMMENT '是否销售(1:是 0:否)',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='商品表';
```

到这里，我们通过创建电商项目业务流程的 ER 模型，再把 ER 模型转换成具体的数据表的过程，完成了利用 ER 模型设计电商项目数据库的工作。

其实，任何一个机遇数据库的应用项目，都可以通过这种先建立 ER 模型，再转换成数据表的方式，完成数据库的设计工作。创建 ER 模型不是目的，目的是把业务逻辑梳理清楚，设计出优秀的数据库。建议不是为了建模而建模，要利用创建 ER 模型的过程来整理思路，这样创建 ER 模型才有意义。

![er模型](/mysql/er模型.png)

### 8. 数据表的设计原则

综合以上内容，总结出数据表设计的一般原则：三少一多

- 数据表的个数越少越好

  RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图 (Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。

- 数据表中的字段个数越少越好

  字段个数越多，数据冗余的可能性越大。设置字段个数的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。

- 数据表中联合主键的字段个数越少越好

  设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式 (也就是用多个字段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。

- 使用主键和外键越多越好

  数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。

三少一多原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。

> 注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。

### 9. 数据库对象编写建议

#### 9.1 关于库

- 【强制】库的名称必须控制在 32 个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。

- 【强制】库名中英文一律小写，不同单词采用下划线分割。须见名知意。

- 【强制】库的名称格式：业务系统名称_子系统名。

- 【强制】库名禁止使用关键字，如 type，order 等。

- 【强制】创建数据库时必须显示指定字符集，并且字符集只能是 utf8 或者 utf8mb4.

  创建数据库 SQL 举例：`CREATE DATABASE crm_fund DEFAULT CHARACTER SET 'utf8';`

- 【建议】对于程序连接数据库账号，遵循权限最小原则

  使用数据库账号只能在一个 DB 下使用，不准跨库。程序使用的账号原则上不准有 DROP 权限。

- 【建议】临时库以 tmp_ 为前缀，并以日期为后缀。备份库以 bak_ 为前缀，并以日期为后缀。

#### 9.2 关于表、列

- 【强制】表和列的名称必须控制在 32 个字符以内，表明只能使用英文字母、数字和下划线，建议以英文字母开头。

- 【强制】表明、列名一律小写，不同单词采用下划线分割。须见名知意。

- 【强制】表明要求有模块名强相关，同一模块的表明尽量使用统一前缀。比如：crm_fund_item

- 【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。

- 【强制】表名、列名禁止使用关键字 (如 type、order 等)

- 【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为 InnoDB。

- 【强制】建表必须有 comment。

- 【强制】字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司 ID，不要使用 corporation_id，而用 corp_id。

- 【强制】布尔值类型的字段命名为 is_描述。如 member 表上表示是否为 enabled 的会员的字段命名为 is_enabled。

- 【强制】禁止在数据库中存储图片、文件等大的二进制数据。

  通常文件很大，短时间内造成数据量快速增长，数据库进行数据读取时，通常会进行大量的随机 I/O 操作，文件很大时，IO 操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。

- 【建议】建表时关于主键：表必须有主键

    - 强制要求主键为 id，类型为 int 或 bigint，且为 AUTO_INCREMENT 建议使用 UNSIGNED 无符号型。
    - 标识表里每一行主体的字段不要设为主键，建议设为其他字段如 user_id，order_id 等，并建立 unique key 索引。因为如果设为主键且主键值为随机插入，则会导致 innodb 内部页分裂和大量随机 I/O，性能下降。

- 【建议】核心表 (如用户表) 必须有行数据的创建时间字段 (create_time) 和最后更新时间字段 (update_time)，便于查问题。

- 【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT 值。

  因为使用 NULL 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。

- 【建议】所有存储相同数据的列名和列类型必须一致 (一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，到值查询效率降低)。

- 【建议】中间表 (或临时表) 用于保留中间结果集，名称以 tmp_ 开头。备份表用于备份或抓取原表快照，名称以 bak_ 开头。中间表和备份表定期清理。

- 【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语句，方便数据库和数据表结构的导出和导入。

#### 9.3 关于索引

- 【强制】InnoDB 表必须主键为 id int / bigint auto_increment，且主键值禁止被更新。

- 【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 BTREE。

- 【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。

- 【建议】多单词组成的 columnname，取前几个单词首字母，加末单词组成 column_name。如：sample 表member_id 上的索引：idx_sample_mid。

- 【建议】单个表上的索引个数不能超过 6 个。

- 【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。

- 【建议】在多表 JOIN 的 SQL 里，保证被驱动表的连接列上有索引，这样 JOIN 执行效率最高。

- 【建议】建表或加索引时，保证表里互相不存在冗余索引。

  比如：如果表里已经存在 key(a,b)，则 key(a) 为冗余索引，需要删除。

#### 9.4 SQL 编写

- 【强制】程序端 SELECT 语句必须指定具体字段名称，禁止写成 *。

- 【建议】程序端 INSERT 语句制定具体字段名称，不要写成 INSERT INTO t1 VALUES(...)。

- 【建议】除静态表或小表 (100 行以内)，DML 语句必须有 WHERE 条件，且使用索引查找。

- 【建议】INSERT INTO ... VALUES(xx),(xx),(xx).. 这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。

- 【建议】SELECT 语句不要使用 UNION，推荐使用 UNION ALL，并且 UNION 字句个数限制在 5 个以内。

- 【建议】线上环境，多表 JOIN 不要超过 5 个表。

- 【建议】减少使用 ORDER BY，和业务沟通能不排序就不排序，获奖排序放到程序段去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。

- 【建议】包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。

- 【建议】对单表的多次 ALTER 操作必须合并为一次

  对于超过 100w 行的大表进行 alter table，必须经过 DBA 审核，并在业务低峰期执行，多个 alter 需整合在一起。因为 alter table 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。

- 【建议】批量操作数据时，需要控制事物处理间隔时间，进行必要的 sleep。

- 【建议】事物里包含 SQL 不超过 5 个。

  因为过长的事物会导致锁数据较久，MySQL 内部缓存、连接消耗过多等问题。

- 【建议】事物里更新语句尽量基于主键或 UNIQUE KEY，如 UPDATE ... WHERE id = xxx;

  否则会产生间隙锁，内部扩大锁定范围，到值系统性能下降，产生死锁。