---
title: 性能分析工具的使用
createTime: 2024/12/19 14:21:53
permalink: /database/668yxbof/
---

在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。

### 1. 数据库服务器的优化步骤

当我们遇到数据库调优问题的时候，该如何思考呢？思考的的整个流程图分成了观察 Show status 和行动 Action 两个部分。字母 S 的部分代表观察 (会使用相应的分析工具)，字母 A 代表的部分是行动 (对应分析可以采取的行动)。

![数据库服务器的优化流程图](/mysql/数据库服务器优化流程图.png)

我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的 SQL 都有哪些，查看具体的 SQL 执行计划，甚至是 SQL 执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。

**详细解释一下上图**：

首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、

促销活动等。这样的话，我们可以通过 A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。

如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入 S2 这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置 long_query_time 参数定义慢的阈值，如果 SQL 执行实际那超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。

在 S3 这一步骤中，我们就知道了执行慢的 SQL，这样就可以针对性地使用 EXPLAIN 查看对应 SQL 语句的执行计划，或者使用 show profile 查看 SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。

如果是 SQL 等待时间长，我们进入 A2 步骤。在这一步骤中，我们可以调优服务器的参数，比如适当增加数据库缓冲池。如果是 SQL 执行时间长，就进入 A3 步骤，这一步中我们需要考虑是索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。

如果 A2 和 A3 都不能解决问题，我们需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈，如果确认没有到达性能瓶颈，就需要重新检查，重复以上的步骤。如果已经到达了性能瓶颈，进入 A4 阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表，比如垂直分库、垂直分表和水平分表等。

以上就是数据库调优的流程思路。如果我们发现执行 SQL 时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤：慢查询、EXPLAIN 和 SHOW PROFILING。

**小结**：

![性能分析](/mysql/性能分析.png)

### 2. 查看系统性能参数

在 MySQL 中，可以使用 SHOW STATUS 语句查询一些 MySQL 数据库服务器的性能参数、执行效率。

SHOW STATUS 语句语法如下：

```sql
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

一些常用的性能参数如下：

- Connections：连接 MySQL 服务器的次数。
- Uptime：MySQL 服务器上线时间。
- Slow_queries：慢查询的次数。
- Innodb_rows_read：Select 查询返回的行数。
- Innodb_rows_inserted：执行 INSERT 操作插入的行数。
- Innodb_rows_updated：执行 UPDATE 操作更新的行数。
- Innodb_rows_deleted：执行 DELETED 擦欧总删除的行数。
- Com_select：查询操作的次数。
- Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。
- Com_update：更新操作的次数。
- Com_delete：删除操作的次数。

### 3. 统计 SQL 的查询成本：last_query_cost

一条 SQL 查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL 会计算每个执行计划所需要的成本，从中选择成本最小的一个座位最终执行的执行计划。

如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的last_query_cost 变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是 SQL 语句所需要读取的页的数量。

例如：想要在 student 表中查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：

```sql
SELECT student_id, class_id, NAME, create_time FROM student_info
WHERE id = 900001;
```

运行结果 (1 条记录，运行时间为 0.015s)

然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：

```sql
SHOW STATUS LIKE 'last_query_cost';

#结果
last_query_cost = 1.000000
```

如果想要查询 id 在 900001 到 900100 之间的学生记录：

```sql
SELECT student_id, class_id, NAME, create_time FROM student_info
WHERE id BETWEEN 900001 AND 900100;
```

运行结果 (100 条记录，运行时间为 0.004s)

查看优化器成本

```sql
SHOW STATUS LIKE 'last_query_cost';

#结果
last_query_cost = 20.290432
```

能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。

使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到一下两点结论：

- **位置决定效率**。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
- **批量决定效率**。如果我们从磁盘中对单一页进行随机读，那么效率是很低的 (差不多 10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。

所以说，遇到 I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

### 4. 定位执行慢的 SQL：慢查询日志

MySQL 的慢查询日志，用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上 (不包含 10 秒) 的语句，认为是超出了我们的最大忍耐时间值。

它的主要作用是，帮助我们发现那些执行时间特别长的 SQL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条 SQL 执行超过 15s，我们就算慢 SQL，希望能收集超过 5s 的 SQL，结合 EXPLAIN 进行全面分析。

默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是条有需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持 将日志记录写入文件。

#### 4.1 开启慢查询日志参数

**开启 slow_query_log**

在使用前，需要先看下慢查询是否已经开启 `show variables like '%slow_query_log';` ，如果是 off 状态，使用 `set global slow_query_log='ON';` 开启。使用 `show variables like '%slow_query_log%';` 查看慢查询日志文件的位置。

#### 4.2 修改 long_query_time 阈值

使用 `show variables like '%long_query_time%';` 查看慢查询的时间阈值设置，使用 `set global long_query_time = 1;` 修改慢查询的时间阈值。使用 `show global status like '%slow_queries%';` 查看当前系统中有多少条慢查询记录。

#### 4.3 案例演示

**分析**

除了上述变量，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 long_query_time 的值，那么，这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。

`show variables like 'min%';` 这个值默认是 0。与 long_query_time=10 合在一起，表示只要查询的执行时间超过 10 秒钟，哪怕一个记录也没有扫描，都要被记录到慢查询日志中。你也可以根据需要，通过修改 my.ini 文件，来修改查询时长，或者通过 SET 命令，用 SQL 语句修改 min_examined_row_limit 的值。

#### 4.4 慢查询日志分析工具：mysqldumpslow

在生产环境中，如果要收工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。

查看 mysqldumpslow 的帮助信息 `mysqldumpslow --help`

```sql
~/ mysqldumpslow --help
Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]

Parse and summarize the MySQL slow query log. Options are

  --verbose    verbose
  --debug      debug
  --help       write this text to standard output

  -v           verbose
  -d           debug
  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default
                al: average lock time
                ar: average rows sent
                at: average query time
                 c: count
                 l: lock time
                 r: rows sent
                 t: query time  
  -r           reverse the sort order (largest last instead of first)
  -t NUM       just show the top n queries
  -a           don't abstract all numbers to N and strings to 'S'
  -n NUM       abstract numbers with at least n digits within names
  -g PATTERN   grep: only consider stmts that include this string
  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),
               default is '*', i.e. match all
  -i NAME      name of server instance (if using mysql.server startup script)
  -l           don't subtract lock time from total time
```

使用 `mysqldumpslow -a -s t -t 5 /opt/homebrew/var/mysql/zhangjiandeMacBook-Pro-slow.log` 定位慢查询 SQL。

#### 4.5 关闭慢查询日志

- 永久性方式

  修改 my.cnf 或 my.ini 文件，把 [mysqld] 组下的 slow_query_log 值设为 OFF，修改保存后，在重启 MySQL 服务，即可生效。

- 临时性方式

    ```sql
    SET GLOBAL slow_query_log=OFF;
    ```

#### 4.6 删除慢查询日志

使用 SHOW 语句显示慢查询日志信息，具体 SQL 语句如下：

`SHOW VARIABLES LIKE 'slow_query_log%';`

从执行结果可以看出慢查询日志的的目录，在该目录下手动删除慢查询日志文件即可。使用命令 `mysqladmin flush-logs` 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。

```sql
mysqladmin -uroot -p flush-logs slow
```

> 提示
>
> 慢查询日志都是使用 mysqladmin flush-logs 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

### 5. 查看 SQL 执行成本：SHOW PROFILE

show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗情况的工具，可用于 SQL 调优的测量。默认情况下处于关闭状态，并保存最近 15 次的运行结果。

```sql
# 查看状态
show variables like 'profiling';
# 开启
set profiling = 'ON';
# 查看当前会话有哪些 profile
show profiles;
# 查看指定 query id
show profile cpu, block io for query 2;
```

**show profile 的常用查询参数**：

- ALL：显示所有的开销信息。
- BLOCK IO：显示块 IO 开销。
- CONTEXT SWITCHES：上下文切换开销。
- CPU：显示 CPU 开销信息。
- IPC：显示发送和接受开销信息。
- MEMORY：显示内存开销信息。
- PAGE FAULTS：显示页面错误开销信息。
- SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。
- SWAPS：显示交换次数开销信息。

**日常开发需要注意的结论**：

- `concerting HEAP to MyISAM`：查询结果太大，内存不够，数据往磁盘上搬了。
- `Creating tmp table`：创建临时表，先拷贝数据到临时表，用完后再删除临时表。
- `Copying to tmp table on disk`：把内存中临时表复制到磁盘上，警惕！
- `locked`。

如果在 show profile 诊断结果中出现了以上 4 条结果中的任何一条，则 SQL 语句需要优化。

> 注意：
>
> 不过 show profile 命令将被弃用，可以从 information_schema 中 profiling 数据表进行查看。

### 6. 分析查询语句：EXPLAIN

#### 6.1 概述

**定位了慢查询的 SQL 之后，我们就可以使用 EXPLAIN 或 DESCRIBE 工具做针对性的分析查询语句**。DESCRIBE 语句的使用方法与 EXPLAIN 语句是一样的，并且分析结果也是一样的。

MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供它认为最优的执行计划 (他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间)。

这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL 为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。

**能做什么**？

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- **哪些索引被实际使用**
- 表之间的引用
- **每张表有多少行被优化器查询**

**[官网介绍](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)**

**版本情况**

- MySQL 5.6.3 以前只能 EXPLAIN SELECT；MySQL 5.6.3 以后就可以 EXPLAIN SELECT、UPDATE、DELETE
- 在 5.7 以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在 5.7 版本后，默认 explain 直接显示 partitions 和 filtered 中的信息。

#### 6.2 基本语法

EXPLAIN 或 DESCRIBE 语句的语法形式如下：

```sql
EXPLAIN SELECT select_options
或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN，就像这样：

```sql
EXPLAIN SELECT 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
```

输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下，我们需要知道应该怎么样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及 UPDATE 语句等都可以加上 EXPLAIN，用来查看这些语句的执行计划，只是平时我们对 SELECT 语句更感兴趣。

> 注意：
>
> 执行 EXPLAIN 时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。

EXPLAIN 语句输出的各个列的作用如下：

| 列名          | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| id            | 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id |
| select_type   | SELECT 关键字对应的那个查询的类型                         |
| table         | 表名                                                      |
| partitions    | 匹配的分区信息                                            |
| type          | 针对单表的访问方法                                        |
| possible_keys | 可能用到的索引                                            |
| key           | 实际上使用的索引                                          |
| key_len       | 实际使用到的索引长度                                      |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
| rows          | 预估的需要读取的记录条数                                  |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比              |
| Extra         | 一些额外的信息                                            |

#### 6.3 数据准备

**建表**

```sql
CREATE TABLE s1 (
	id INT AUTO_INCREMENT,
  key1 VARCHAR(100),
  key2 INT,
  key3 VARCHAR(100),
  key_part1 VARCHAR(100),
  key_part2 VARCHAR(100),
  key_part3 VARCHAR(100),
  common_field VARCHAR(100),
  PRIMARY KEY (id),
  INDEX idx_key1 (key1),
  UNIQUE INDEX idx_key2 (key2),
  INDEX idx_key3 (key3),
  INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;

CREATE TABLE s2 (
	id INT AUTO_INCREMENT,
  key1 VARCHAR(100),
  key2 INT,
  key3 VARCHAR(100),
  key_part1 VARCHAR(100),
  key_part2 VARCHAR(100),
  key_part3 VARCHAR(100),
  common_field VARCHAR(100),
  PRIMARY KEY (id),
  INDEX idx_key1 (key1),
  UNIQUE INDEX idx_key2 (key2),
  INDEX idx_key3 (key3),
  INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;
```

**设置参数 log_bin_trust_function_creators**

创建函数，假如报错，需开启如下命令：允许创建函数设置：

```sql
SET GLOBAL log_bin_trust_function_creators=1;	# 不加 global 只是当前窗口有效。
```

**创建函数**

```sql
DELIMITER //
CREATE FUNCTION rand_string1(n INT)
	RETURNS VARCHAR(255)	#	该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str = CONCAT(return_str, SUBSTRING(chars_str, FLOOR(1 + RAND() * 52), 1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;
```

**创建存储过程**

```sql
DELIMITER //
CREATE PROCEDURE insert_s1 (IN min_num INT (10), IN max_num INT (10))
BEGIN
	DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
	SET i = i + 1;
	INSERT INTO s1 VALUES(
  (min_num + i),
  rand_string1(6),
  (min_num + 30 * i + 5),
  rand_string1(6),
  rand_string1(10),
  rand_string1(5),
  rand_string1(10),
  rand_string1(10));
  UNTIL i = max_num
  END REPEAT;
  COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE insert_s2 (IN min_num INT (10), IN max_num INT (10))
BEGIN
	DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
	SET i = i + 1;
	INSERT INTO s2 VALUES(
  (min_num + i),
  rand_string1(6),
  (min_num + 30 * i + 5),
  rand_string1(6),
  rand_string1(10),
  rand_string1(5),
  rand_string1(10),
  rand_string1(10));
  UNTIL i = max_num
  END REPEAT;
  COMMIT;
END //
DELIMITER ;
```

**调用存储过程**

```sql
CALL insert_s1(10001, 10000);
CALL insert_s2(10001, 10000);
```

#### 6.4 EXPLAIN 各列作用

- table：表名

```sql
# 查询的每一行记录都对应着一个单表
EXPLAIN SELECT * FROM s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

# s1:驱动表  s2:被驱动表
EXPLAIN SELECT * FROM s1 INNER JOIN s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                         |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL                          |
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
# 执行计划中，记录在前的为驱动表，在后的为被驱动表，这里s2为驱动表，s1为被驱动表
```

- id：在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id

```sql
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

EXPLAIN SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key2
WHERE s1.common_field = 'a';
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref                | rows | filtered | Extra                 |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | idx_key1      | NULL     | NULL    | NULL               | 9895 |    10.00 | Using where           |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | mysql_test.s1.key1 |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+

EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2);
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+
| id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref                | rows | filtered | Extra       |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+
|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1            | NULL                | NULL    | NULL               | 9895 |   100.00 | Using where |
|  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_distinct_key> | <auto_distinct_key> | 303     | mysql_test.s1.key1 |    1 |   100.00 | NULL        |
|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key3            | idx_key3            | 303     | NULL               | 9595 |   100.00 | Using index |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+

EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
```

**查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作**

```sql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref                | rows | filtered | Extra                              |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | idx_key1      | NULL     | NULL    | NULL               | 9895 |   100.00 | Using where                        |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | mysql_test.s1.key1 |    1 |    10.00 | Using index condition; Using where |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+
```

**Union 去重**

```sql
EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+

EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```

> - id 如果相同，可以认为是一组，从上往下顺序执行
>
> - 在所有组中，id 值越大，优先级越高，越先执行
> - 关注点：id 号每个号码，表示一趟独立的查询，一个 SQL 的查询趟越少越好数

- select_type

一条大的查询语句里边可以包含若干个 SELECT 关键字，每个 SELECT 关键字代表着一个小的查询语句，而每个 SELECT 关键字的 FROM 字句中都可以包含若干张表 (这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个 SELECT 关键字中的表来说，它们的 id 值是相同的。

MySQL 为每个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，意思是我们只要知道了某个小查询的 select_type 属性，就知道了这个小查询在整个大查询中扮演的一个什么角色，select_type 能取的值：

| 名称                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SIMPLE               | Simple SELECT (not using UNION or subqueries)                |
| PRIMARY              | Outermost SELECT                                             |
| UNION                | Second or later SELECT statement in a UNION                  |
| UNION RESULT         | Result of a UNION                                            |
| SUBQUERY             | FIRST SELECT in subquery                                     |
| DEPENDENT SUBQUERY   | First SELECT in subquery,dependent on outer query            |
| DEPENDENT UNION      | Second or later SELECT statement in a UNION, dependent on outer query |
| DERIVED              | Derived table                                                |
| MATERIALIZED         | Materialized subquery                                        |
| UNCACHEABLE SUBQUERY | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
| UNCACHEABLE UNION    | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |

select_type：SELECT 关键字对应的那个查询的类型，确定小查询在整个大查询中扮演了一个什么角色

具体分析：

1. SIMPLE

   查询语句中不包含 UNION 或者子查询的查询都算是 SIMPLE 类型

```sql
EXPLAIN SELECT * FROM s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

# 连接查询也算是 SIMPLE 类型
EXPLAIN SELECT * FROM s1 INNER JOIN s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                         |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL                          |
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
```

2. UNION RESULT

   对于包含 UNION 或者 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 值就是 PRIMARY。

   对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION。

   MySQL 选择使用临时表来完成 UNION 查询的去重工作，针对该临时表的查询的 select_type 就是 UNION RESULT。

```sql
EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+

EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```

3. SUBQUERY

   如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是不相关子查询。该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 SUBQUERY

```sql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
```

​		如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字		代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY

```sql
EXPLAIN SELECT * FROM s1
WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
+----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+
| id | select_type        | table | partitions | type   | possible_keys     | key      | key_len | ref                | rows | filtered | Extra       |
+----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+
|  1 | PRIMARY            | s1    | NULL       | ALL    | idx_key3          | NULL     | NULL    | NULL               | 9895 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | eq_ref | idx_key2,idx_key1 | idx_key2 | 5       | mysql_test.s1.key2 |    1 |    10.00 | Using where |
+----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+
# 注意的是，select_type 为 DEPENDENT SUBQUERY 的查询可能会被执行多次
```

​		在包含 UNION 或者 UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，拿出了最左边的那个小查询之外，其余的小		查询的 select_type 的值就是 DEPENDENT UNION。

```sql
EXPLAIN SELECT * FROM s1
WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
| id | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |
+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9895 |   100.00 | Using where              |
|  2 | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using where; Using index |
|  3 | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using where; Using index |
| NULL | UNION RESULT       | <union2,3> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |
+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
```

​		对于派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED。

```sql
EXPLAIN SELECT * FROM (SELECT key1, COUNT(*) AS c FROM s1 GROUP BY key1) AS derived_s1 WHERE c > 1;
+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9895 |   100.00 | NULL        |
|  2 | DERIVED     | s1         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9895 |   100.00 | Using index |
+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
```

​		当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就		是 MATERALIZED。

```sql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);	#	子查询被转化为物化表
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+
| id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref                | rows | filtered | Extra       |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+
|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1            | NULL                | NULL    | NULL               | 9895 |   100.00 | Using where |
|  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_distinct_key> | <auto_distinct_key> | 303     | mysql_test.s1.key1 |    1 |   100.00 | NULL        |
|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1            | idx_key1            | 303     | NULL               | 9595 |   100.00 | Using index |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+
```

- partitions：匹配的分区信息

  代表分区表中的命中情况，非分区表，该项为 NULL。一般情况下我们的查询语句的执行计划的 partitions 列的值都是 NULL。

- **type**：针对单表的访问方法

  执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，又称访问类型，其中的 type 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到 type 列的值是 ref，表明 MySQL 即将使用 ref 访问方法来执行对 s1 表的查询。

  完整的访问方法如下：system, const, eq_ref, ref, fulltext, ref_or_null, index_merge, unique_subquery, index_subquery, range, index, ALL。

    - 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、MEMORY，那么对该表的访问方法就是 system。

        ```sql
        CREATE TABLE t(i INT) ENGINE=MyISAM;
        INSERT INTO t VALUES(1);
        EXPLAIN SELECT * FROM t;
        
        +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
        | id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
        +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
        |  1 | SIMPLE      | t     | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
        +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
        ```

    - 当根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const

        ```sql
        EXPLAIN SELECT * FROM s1 WHERE id = 10005;
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        
        EXPLAIN SELECT * FROM s1 WHERE key2 = 10066;
        +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
        | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |
        +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
        ```

    - 在连接查询时，如果被驱动表时通过主键或者唯一二级索引列等值匹配的方式进行访问的 (如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较)，则对该被驱动表的访问方法就是 eq_ref。

        ```sql
        EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
        +----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+
        | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref              | rows | filtered | Extra |
        +----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+
        |  1 | SIMPLE      | s2    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL             | 9595 |   100.00 | NULL  |
        |  1 | SIMPLE      | s1    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | mysql_test.s2.id |    1 |   100.00 | NULL  |
        +----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+
        ```

    - 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref

        ```sql
        EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
        +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
        | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
        +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
        ```

    - 当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null

        ```sql
        EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
        +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
        | id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |
        +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
        |  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    2 |   100.00 | Using index condition |
        +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
        ```

    - 单表访问方法时在某些场景下可以使用 Intersection、Union、Sort-Union 这三种索引合并的方式来执行查询

        ```sql
        EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
        +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
        | id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
        +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
        |  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
        +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
        ```

    - unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery。

        ```sql
        EXPLAIN SELECT * FROM s1
        WHERE key2 IN (SELECT id FROM s2 WHERE s1.key1 = s2.key1) OR key3 = 'a';
        +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
        | id | select_type        | table | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |
        +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
        |  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9895 |   100.00 | Using where |
        |  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |
        +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
        ```

    - 如果使用索引获取某些范围区间的记录，那么就可能使用到 range 访问方法

        ```sql
        EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
        +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
        | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
        +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
        |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    3 |   100.00 | Using index condition |
        +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
        ```

    - 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index

        ```sql
        EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
        +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
        | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
        +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
        |  1 | SIMPLE      | s1    | NULL       | index | idx_key_part  | idx_key_part | 909     | NULL | 9895 |    10.00 | Using where; Using index |
        +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
        ```

    - 全表扫描

        ```sql
        EXPLAIN SELECT * FROM s1;
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
        |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
        1 row in set, 1 warning (0.00 sec)
        ```

    - 小结

      结果值从最好到最坏依次是：

      **system** > **const** > **eq_ref** > **ref** > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > **range** > **index** > **ALL**

      其中比较重要的几个提取出来 (加粗的)。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts 级别。

- possible_keys 和 key (可能用到的索引和实际上使用的索引)

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | const |    1 |     5.00 | Using where |
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    ```

- key_len：实际使用到的索引长度 (即：字节数)

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE id = 10005;
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    ```

- ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。

  比如知识一个常数或者是某个列。

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    
    EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref              | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+
    |  1 | SIMPLE      | s2    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL             | 9595 |   100.00 | NULL  |
    |  1 | SIMPLE      | s1    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | mysql_test.s2.id |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+
    ```

- rows：预估的需要读取的记录条数，值越小越好

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE key1 > 'z';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  366 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    ```

- filtered：某个表经过搜索条件过滤后剩余记录条数的百分比。

  如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND common_field = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                              |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  366 |    10.00 | Using index condition; Using where |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    ```

  对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值，它决定了被驱动表要执行的次数 (即：rows * filtered)

    ```sql
    EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL               | 9895 |    10.00 | Using where |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | mysql_test.s1.key1 |    1 |   100.00 | NULL        |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
    ```

- Extra：一些额外的信息，更准确的理解 MySQL 到底将如何执行给定的查询语句。

  当查询语句没有 FROM 字句时将会提示该额外信息

    ```sql
    EXPLAIN SELECT 1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    ```

  查询语句的 WHERE 字句永远为 FALSE 时将会提示该额外信息

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE 1 != 1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
    ```

  当我们使用全表扫描来执行对某个表的查询，并且该语句的 WHERE 字句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE common_field = 'a';
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |    10.00 | Using where |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    ```

  当查询列表处有 MIN 或者 MAX 聚合函数，但是并没有符合 WHERE 字句中国呢的搜索条件的记录时，将会提示该额外信息

    ```sql
    EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg';
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                   |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching min/max row |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
    ```

  当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在 Extra 列将会提示该额外信息。比方说下边这个查询中只需要用到 idx_key1 而不需要回表操作：

    ```sql
    EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using index |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
    ```

  有些搜索条件中虽然出现了索引列，但却不能使用到索引

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  366 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    ```

  在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所说的基于块的嵌套循环算法

    ```sql
    EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9595 |   100.00 | NULL                                       |
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |    10.00 | Using where; Using join buffer (hash join) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
    ```

  当我们使用左连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息

    ```sql
    EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref                | rows | filtered | Extra                   |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL               | 9895 |   100.00 | NULL                    |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | mysql_test.s1.key1 |    1 |    10.00 | Using where; Not exists |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+
    ```

  如果执行计划的 Extra 列出现了 Using intersect(...) 提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的 ... 表示需要进行索引合并的索引名称。如果出现了 Using union(...) 提示，说明准备使用 Union 索引合并的方式执行查询。出现了 Using sort union(...) 提示，说明准备使用 Sort-Union 索引合并的方式执行查询。

    ```sql
    EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    | id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    ```

  当我们的 LIMIT 子句的参数为 0 时，表示压根不打算从表中读出任何记录，将会提示该额外信息

    ```sql
    EXPLAIN SELECT * FROM s1 LIMIT 0;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra      |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Zero limit |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+
    ```

  有一些情况对结果集中的记录进行排序是可以使用到索引的。

    ```sql
    EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+
    ```

  很多情况下排序操作无法使用到索引，只能在内存中 (记录较少的时候) 或者磁盘中 (记录较多的时候) 进行排序，MySQL 把这种在内存或者磁盘上进行排序的方式统称为文件排序 (英文名：filesort)

  如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort 提示

    ```sql
    EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | Using filesort |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    ```

  在许多查询的执行过程中，MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示。

    ```sql
    EXPLAIN SELECT DISTINCT common_field FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | Using temporary |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    ```

  执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表。比如：扫描指定的索引 idx_key1 即可。

    ```sql
    EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9895 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    ```

- 小结

    - EXPLAIN 不考虑各种 cache
    - EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作
    - EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
    - 部分统计信息是估算的，并非精确值

### 7. EXPLAIN 的进一步使用

#### 7.1 EXPLAIN 四种输出格式

- 传统格式

  传统格式简单明了，输出是一个表格形式，概要说明查询计划。

    ```sql
    EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
    |  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL               | 9595 |    90.00 | Using where |
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | mysql_test.s2.key1 |    1 |   100.00 | Using index |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
    ```

- JSON 格式

  第一种格式中介绍的 EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性——成本。而 JSON 格式是四种格式里面输出信息最详尽的格式，里面包含了执行的成本信息。

    - JSON 格式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT=JSON。

        ```sql
        EXPLAIN FORMAT=JSON SELECT ......
        ```

    - EXPLAIN 的 Column 与 JSON 的对应关系

      | Column        | JSON Name     | Meaning                                        |
              | ------------- | ------------- | ---------------------------------------------- |
      | id            | select_id     | The SELECT identifier                          |
      | select_type   | None          | The SELECT type                                |
      | table         | table_name    | The table for the output row                   |
      | partitions    | partitions    | The matching partitions                        |
      | type          | access_type   | The join type                                  |
      | possible_keys | possible_keys | The possible indexes to choose                 |
      | key           | key           | The index actually chosen                      |
      | ken_len       | key_length    | The length of the chosen key                   |
      | ref           | ref           | The columns compared to the index              |
      | rows          | rows          | Estimate of rows to be examined                |
      | filtered      | filtered      | Percentage of rows filtered by table condition |
      | Extra         | None          | Additional information                         |

        ```sql
        EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
        *************************** 1. row ***************************
        EXPLAIN: {
          "query_block": {
            "select_id": 1,
            "cost_info": {
              "query_cost": "1360.07"
            },
            "nested_loop": [
              {
                "table": {
                  "table_name": "s1",
                  "access_type": "ALL",
                  "possible_keys": [
                    "idx_key1"
                  ],
                  "rows_examined_per_scan": 9895,
                  "rows_produced_per_join": 989,
                  "filtered": "10.00",
                  "cost_info": {
                    "read_cost": "914.80",
                    "eval_cost": "98.95",
                    "prefix_cost": "1013.75",
                    "data_read_per_join": "1M"
                  },
                  "used_columns": [
                    "id",
                    "key1",
                    "key2",
                    "key3",
                    "key_part1",
                    "key_part2",
                    "key_part3",
                    "common_field"
                  ],
                  "attached_condition": "((`mysql_test`.`s1`.`common_field` = 'a') and (`mysql_test`.`s1`.`key1` is not null))"
                }
              },
              {
                "table": {
                  "table_name": "s2",
                  "access_type": "eq_ref",
                  "possible_keys": [
                    "idx_key2"
                  ],
                  "key": "idx_key2",
                  "used_key_parts": [
                    "key2"
                  ],
                  "key_length": "5",
                  "ref": [
                    "mysql_test.s1.key1"
                  ],
                  "rows_examined_per_scan": 1,
                  "rows_produced_per_join": 989,
                  "filtered": "100.00",
                  "index_condition": "(cast(`mysql_test`.`s1`.`key1` as double) = cast(`mysql_test`.`s2`.`key2` as double))",
                  "cost_info": {
                    "read_cost": "247.38",
                    "eval_cost": "98.95",
                    "prefix_cost": "1360.08",
                    "data_read_per_join": "1M"
                  },
                  "used_columns": [
                    "id",
                    "key1",
                    "key2",
                    "key3",
                    "key_part1",
                    "key_part2",
                    "key_part3",
                    "common_field"
                  ]
                }
              }
            ]
          }
        }
        ```

      s1 表的的成本计算：

        ```sql
        "cost_info": {
          "read_cost": "914.80",
          "eval_cost": "98.95",
          "prefix_cost": "1013.75",
          "data_read_per_join": "1M"
        }
        ```

        - read_cost 是由下边这两部分组成的：

            - IO 成本
            - 检测 `rows * (1 - filter)` 条记录的 CPU 成本

          > rows 和 filter 都是前边介绍执行计划的输出列，在 JSON 格式的执行计划中，rows 相当于 rows_wxamined_per_scan，filtered 名称不变。

        - eval_cost 是这样计算的：

          检测 `rows * filter` 条记录的成本

        - prefix_cost 就是单独查询 s1 表的成本，也就是：

          `read_cost + eval_cost`

        - data_read_per_join 表示在此次查询中需要读取的数据量。

      对于 s2 表的 cost_info 部分是这样的：

        ```sql
        "cost_info": {
          "read_cost": "247.38",
          "eval_cost": "98.95",
          "prefix_cost": "1360.08",
          "data_read_per_join": "1M"
        }
        ```

      由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次 s2 表后累加起来的值，主要关注里边的 prefix_cost 的值代表的是整个连接查询预计的成本，也就是单词查询 s1 表和多次查询 s2 表后的成本的和，也就是：

      `247.38 + 98.95 + 1013.75 = 1360.08`

- TREE 格式

  TREE 格式是 8.0.16 版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。

    ```sql
    EXPLAIN FORMAT=TREE SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
    EXPLAIN: -> Nested loop inner join  (cost=1360.08 rows=990)
        -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=1013.75 rows=990)
            -> Table scan on s1  (cost=1013.75 rows=9895)
        -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)
    ```

- 可视化输出

  可视化输出，可以通过 MySQL Workbench 可视化查看 MySQL 的执行计划。通过点击 workbench 的放大镜图标，即可生成可视化的查询计划。


#### 7.2 SHOW WARNINGS 的使用

在使用 EXPLAIN 语句查看了某个查询的执行计划之后，紧接着还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一下扩展信息。

```sql
EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
+----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL               | 9595 |    90.00 | Using where |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | mysql_test.s2.key1 |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+

SHOW WARNINGS \G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `mysql_test`.`s1`.`key1` AS `key1`,`mysql_test`.`s2`.`key1` AS `key1` from `mysql_test`.`s1` join `mysql_test`.`s2` where ((`mysql_test`.`s1`.`key1` = `mysql_test`.`s2`.`key1`) and (`mysql_test`.`s2`.`common_field` is not null))
```

可以看到 SHOW WARNINGS 展示出来的信息有三个字段：Level、Code、Message。最常见的就是 Code 为 1003 的信息，当 Code 为 1003 时，Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如上边的查询本来是一个左外连接查询，但是有一个 s2.common_field IS NOT NULL 的条件，就会导致查询优化器把左外连接查询优化为内连接查询，从 SHOW WARNINGS 的 Message 字段也可以看出来，原本的 LEFT JOIN 已经变成了 JOIN。

### 8. 分析优化器执行计划：trace

OPTIMIZER_TRACE 是 MySQL 5.6 引入的一项跟踪功能，它可以跟踪优化器做出的各种决策 (比如访问表的方法、各种开销计算、各种转换等)，并将跟踪结果记录到 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表中。

此功能默认关闭。开启 trace，并设置格式为 JSON，同时设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

```sql
SET optimizer_trace='enable=on',end_markers_in_json=on;
SET optimizer_trace_max_mem_size=1000000;
```

开启后，可分析如下语句：

- SELECT
- INSERT
- REPLACE
- UPDATE
- DELETE
- EXPLAIN
- SET
- DECLARE
- CASE
- IF
- RETURN
- CALL

执行 SQL 后执行 `SELECT * FROM information_schema.optimizer_trace \G`

结果包括四部分：

- 查询语句
- QUERY 字段对应语句的跟踪信息
- 跟踪信息过长时，被截断的跟踪信息的字节数
- 执行跟踪语句的用户是否有查看对象的权限，当不具有权限时，该列信息为 1 且 TRACE 字段为空，一般在调用带有 SQL SECURITY DEFINER 的视图或者是存储过程的情况下，会出现此问题。

### 9. MySQL 监控分析视图 - sys schema

关于 MySQL 的性能监控和问题诊断，我们一般都从 performance_schema 中去获取想要的数据，在 MySQL 5.7.7 版本中新增 sys schema，它将 performance_schema 和 information_schema 中的数据以更容易理解的方式总结归纳为视图，其目的就是为了降低查询 performance_schema 的复杂度，让 DBA 能够快速的定位问题。

#### 9.1 Sys schema 视图摘要

- 主机相关：以 host_summary开头，主要汇总了 IO 延迟的信息。
- Innodb 相关：以 innodb 开头，汇总了 innodb buffer 信息和事务等待 innodb 锁的信息。
- I/O 相关：以 io 开头，汇总了等待 I/O、I/O 使用量情况。
- 内存使用情况：以 memory 开头，从主机、县城、事件等角度展示内存的使用情况。
- 连接与会话信息：processlist 和 session 相关视图，总结了会话相关信息。
- 表相关：以 schema_table 开头的视图，展示了表的统计信息。
- 索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。
- 语句相关：以 statement 开头，包含了执行全表扫描、使用临时表、排序等的语句信息。
- 用户相关：以 user 开头的视图，统计了用户使用的文件 I/O、执行语句统计信息。
- 等待事件相关信息：以 wait 开头，展示等待事件的延迟情况。

#### 9.2 Sys schema 视图使用场景

**索引情况**

```sql
# 查询冗余索引
select * from sys.schema_redundant_indexes;

# 查询未使用过的索引
select * from sys.schema_unused_indexes;

# 查询索引的使用情况
select index_name, rows_selected, rows_inserted, rows_updated, rows_deleted from sys.schema_index_statistics where table_schema='dbname';
```

**表相关**

```sql
# 查询表的访问量
select table_schema, table_name, sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema, table_name order by io desc;
# 查询占用 bufferpool 较多的表
select object_schema, object_name, allocated, data from sys.innodb_buffer_stats_by_table order by allocated limit 10;

# 查看表的全表扫描情况
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**

```sql
# 监控 SQL 执行的频率
select db, exec_count, query from sys.statement_analysis order by exec_count desc;

# 监控使用了排序的 SQL
select db, exec_count, first_seen, last_seen, query from sys.statements_with_sorting limit 1;

# 监控使用了临时表或磁盘临时表的 SQL
select db, exec_count, tmp_tables, tmp_disk_tables, query from sys.statement_analysis where tmp_tables > 0 or tmp_disk_tables > 0 order by (tmp_tables + tmp_disk_tables) desc;
```

**IO 相关**

```sql
# 查看消耗磁盘 IO 的文件
select file, avg_read, avg_write, avg_read + avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb 相关**

```sql
# 行锁阻塞情况
select * from sys.innodb_lock_waits;
```

> 风险提示：
>
> 通过 sys 库去查询时，MySQL 会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询 sys 或者 performance_schema、information_schema 来完成监控、巡检等工作。